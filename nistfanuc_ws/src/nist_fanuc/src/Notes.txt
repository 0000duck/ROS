
lrmate200id_macro.xacro

    <joint name="${prefix}joint_6-tool0" type="fixed">
<!--      <origin xyz="0 0 0" rpy="${m_pi} ${-m_pi_2} 0" /> -->
      <origin xyz="0 0 0" rpy="0 0 0" />
     <parent link="${prefix}link_6" />
      <child link="${prefix}robotiq_85_adapter_link" />
     <axis xyz="0 0 0"/> <!-- no rotation -->
    </joint>

  <link name="${prefix}robotiq_85_adapter_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_adapter_plate.dae"/>
      </geometry>
      <origin rpy="1.5707 0 1.5707" xyz="0 0 0"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_adapter_plate.dae"/>
      </geometry>
      <origin rpy="0 0 1.5707" xyz="0 0 0"/>
    </collision>
  </link>

  <!--  /\  -->
  <joint name="${prefix}robotiq_85_base_joint" type="fixed">
    <parent link="${prefix}robotiq_85_adapter_link"/>
    <child link="${prefix}robotiq_85_base_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="0 0 0" xyz=".0085 0 -.0041"/>
  </joint>
  <!--  \/  -->

  <link name="${prefix}robotiq_85_base_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_base.dae"/>
      </geometry>
      <origin rpy="3.1415 0 1.5707" xyz="0 0 0"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_base.dae"/>
      </geometry>
      <origin rpy="1.5707 0 1.5707" xyz="0 0 0"/>
    </collision>
  </link>

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_left_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="-1.5707 1.5707 0" xyz=".04191 .0306 0"/>
    <limit lower="0" upper=".8575" velocity="2.0" effort="1000"/>
  </joint>

  <joint name="${prefix}robotiq_85_right_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_right_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="1.5707 -1.5707 0" xyz=".04191 -.0306 0"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" multiplier="1"/>
  </joint>
  <!--  \/  -->
  <!--  \/  -->

  <link name="${prefix}robotiq_85_left_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_0_L.dae"/>
      </geometry>
      <origin rpy="3.14159 -1.5707 0" xyz="0 .04191 -.0306"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_0_L.dae"/>
      </geometry>
      <origin rpy="1.5707 -1.5707 0" xyz="0 .04191 -.0306"/>
    </collision>
  </link> 

  <link name="${prefix}robotiq_85_right_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_0_R.dae"/>
      </geometry>
      <origin rpy="3.14159 1.5707 0" xyz="0 .04191 -.0306"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_0_R.dae"/>
      </geometry>
      <origin rpy="1.5707 1.5707 0" xyz="0 .04191 -.0306"/>
    </collision>
  </link>

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_finger_joint" type="fixed">
    <parent link="${prefix}robotiq_85_left_knuckle_link"/>
    <child link="${prefix}robotiq_85_left_finger_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="3.1415 0 0" xyz="0 .00508 .03134"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
  </joint>

  <joint name="${prefix}robotiq_85_right_finger_joint" type="fixed">
    <parent link="${prefix}robotiq_85_right_knuckle_link"/>
    <child link="${prefix}robotiq_85_right_finger_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="3.1415 0 0" xyz="0 .00508 .03134"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
  </joint>
  <!--  \/  --> 
  <!--  \/  -->  

  <link name="${prefix}robotiq_85_left_finger_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_1_L.dae"/>
      </geometry>
      <origin rpy="0 1.5707 0" xyz="0 -.03683 .06194"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_1_L.dae"/>
      </geometry>
      <origin rpy="-1.5707 1.5707 0" xyz="0 -.03683 .06194"/>
    </collision>
  </link> 

  <link name="${prefix}robotiq_85_right_finger_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_1_R.dae"/>
      </geometry>
      <origin rpy="0 -1.5707 0" xyz="0 -.03683 .06194"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_1_R.dae"/>
      </geometry>
      <origin rpy="-1.5707 -1.5707 0" xyz="0 -.03683 .06194"/>
    </collision>
  </link> 

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_inner_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_left_inner_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="1.5707 1.5707 0" xyz=".04843 .0127 0"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" offset="0"/>
  </joint> 

  <joint name="${prefix}robotiq_85_right_inner_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_right_inner_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="-1.5707 -1.5707 0" xyz=".04843 -.0127 0"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" offset="0"/>
  </joint>
  <!--  \/  --> 
  <!--  \/  -->  

  <link name="${prefix}robotiq_85_left_inner_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_2_L.dae"/>
      </geometry>
      <origin rpy="0 1.5707 0" xyz="0 -.04843 .0127"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_2_L.dae"/>
      </geometry>
      <origin rpy="-1.5707 1.5707 0" xyz="0 -.04843 .0127"/>
    </collision>
  </link>

  <link name="${prefix}robotiq_85_right_inner_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_2_R.dae"/>
      </geometry>
      <origin rpy="0 -1.5707 0" xyz="0 -.04843 .0127"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_2_R.dae"/>
      </geometry>
      <origin rpy="-1.5707 -1.5707 0" xyz="0 -.04843 .0127"/>
    </collision>
  </link>

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_finger_tip_joint" type="revolute">
    <parent link="${prefix}robotiq_85_left_inner_knuckle_link"/>
    <child link="${prefix}robotiq_85_left_finger_tip_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="0 0 0" xyz="0 .04196 -.0388"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" multiplier="-1"/>
  </joint>

  <joint name="${prefix}robotiq_85_right_finger_tip_joint" type="revolute">
    <parent link="${prefix}robotiq_85_right_inner_knuckle_link"/>
    <child link="${prefix}robotiq_85_right_finger_tip_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="0 0 0" xyz="0 .04196 -.0388"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" multiplier="-1"/>
  </joint>
  <!--  \/  --> 
  <!--  \/  -->  

  <link name="${prefix}robotiq_85_left_finger_tip_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_3_L.dae"/>
      </geometry>
      <origin rpy="0 1.5707 0" xyz="0 -.090381 .051505"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_3_L.dae"/>
      </geometry>
      <origin rpy="-1.5707 1.5707 0" xyz="0 -.090381 .051505"/>
    </collision>
  </link> 

  <link name="${prefix}robotiq_85_right_finger_tip_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_3_R.dae"/>
      </geometry>
      <origin rpy="0 -1.5707 0" xyz="0 -.090381 .051505"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_3_R.dae"/>
      </geometry>
      <origin rpy="-1.5707 -1.5707 0" xyz="0 -.090381 .051505"/>
    </collision>
  </link>


   void RvizSetup() {
        tf::Quaternion qidentity(0.0, 0.0, 0.0, 1.0);

        for (size_t row = 0; row < rows; row++) {
            double rowoffset = xoffset + (offset * row);
            for (size_t i = 0; i <= cols; i = i + 2) {
                double coloffset = yoffset + (i * offset);
                if (row % 2 == 0) coloffset = coloffset + offset; // red offset at zero

                Eigen::Vector3d up(rowoffset, coloffset, 0.01);
                Eigen::Vector3d down(rowoffset + offset, coloffset + offset, 0.0);
                std::string sqname = Globals.StrFormat("Square[%d:%d]", row, i);
                ObjectDB * obj = new ObjectDB(sqname,
                        "Checkerboard",
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(up))),
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(down))),
                        rviz_visual_tools::WHITE);
                obj->centroid = Eigen::Vector3d(rowoffset + offset / 2.0, coloffset + offset / 2.0, .01);
                ObjectDB::Save(obj);

                ObjectDB * checker;
                size_t checkercol = (row % 2 == 0) ? i + 1 : i; //  coloffset = coloffset + offset; // red offset at zero
                rviz_visual_tools::colors checkercolor = rviz_visual_tools::CLEAR;
                if (row < 3) checkercolor = rviz_visual_tools::RED;
                if (row >= 5) checkercolor = rviz_visual_tools::BLACK;
                if (checkercolor != rviz_visual_tools::CLEAR) {
                    std::string checkername = Globals.StrFormat("Checker[%d:%d]", row, checkercol);
                    checker = new ObjectDB(checkername,
                            "Cylinder",
                            Eigen::Affine3d(Eigen::Translation3d(obj->centroid)),
                            checkercolor,
                            height,
                            radius ,
                            "Cylinder");
                    ObjectDB::Save(checker);
                }

                if (row % 2 == 0) coloffset = coloffset - offset; // red offset at zero
                else coloffset = coloffset + offset;
                Eigen::Vector3d bup(rowoffset, coloffset, 0.01);
                Eigen::Vector3d bdown(rowoffset + offset, coloffset + offset, 0.0);
                sqname = Globals.StrFormat("Square[%d:%d]", row, i);
                obj = new ObjectDB(sqname,
                        "Checkerboard",
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(bup))),
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(bdown))),
                        rviz_visual_tools::BLACK);
                obj->centroid = Eigen::Vector3d(rowoffset + offset / 2.0, coloffset + offset / 2.0, 0.01);
                ObjectDB::Save(obj);
            }
        }
    }


  +---+---+---+---+---+---+---+---+
0 |   | r |   | B |   | r |   | r |
  +---+---+---+---+---+---+---+---+
1 |   |   |   |   |   |   | r |   |
  +---+---+---+---+---+---+---+---+
2 |   |   |   |   |   | r |   |   |
  +---+---+---+---+---+---+---+---+
3 |   |   | r |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
4 |   |   |   |   |   | b |   | b |
  +---+---+---+---+---+---+---+---+
5 |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
6 |   | b |   | b |   |   |   | b |
  +---+---+---+---+---+---+---+---+
7 | b |   |   |   |   |   | b |   |
  +---+---+---+---+---+---+---+---+
    0   1   2   3   4   5   6   7
#if 0
class SimpleMotionInterpreter: public RCSInterpreter
{
public:
	/*!
	* \brief RCSInterpreter constructor that optionally accepts pointer to kinematic instance.
	\param k is the kinematics pointer
	*/
    SimpleMotionInterpreter(IKinematicsSharedPtr k = NULL);
    ~SimpleMotionInterpreter(void);

	/*!
	* \brief ParseCommand parses a RCS command and queues robot motion commands.
	\param cmd is the command to interpret
	*/
    virtual int ParseCommand(RCS::CanonCmd cmd);
protected:
	/*!
	* \brief AddJointCommands  accepts vector of joint trajectories and adds to robot motion queue.
	\param gotojoints is the vector of joint states describing the motion.
	*/
    void AddJointCommands(std::vector<JointState > gotojoints);

	/*!
	* \brief PlanCartesianMotion accepts vector of poses and generates a vector of joint trajectories.
	* Can use a couple of planning algorithms to generate trajectory.
	\param poses is the vector of cartesian motion.
	\return vector of planned joint states
	*/
    std::vector<JointState> PlanCartesianMotion(std::vector<RCS::Pose> poses);

    //////////////////////////////////////////////////
public:
#ifdef DESCARTES
    TrajectoryVec results; /**< descartes motion planner results */
#endif
    std::vector<double> times;  /**< descartes times for  trajectory results */
    IRate rates; /**< rates structure for simple motion planner  */
    MotionControl motioncontrol; /**< instance of simple motion control object  */
 
};
#endif
#ifdef DESCARTES
using namespace descartes_core;
using namespace descartes_trajectory;
#endif

#if 0
SimpleMotionInterpreter::SimpleMotionInterpreter(IKinematicsSharedPtr pKinematics) {
    _kinematics = pKinematics; // hopefully can be null
    //    _kinematics = IKinematicsSharedPtr(new DummyKinematics());
    rates = IRate(DEFAULT_CART_MAX_VEL, DEFAULT_CART_MAX_ACCEL, DEFAULT_LOOP_CYCLE);
}

SimpleMotionInterpreter::~SimpleMotionInterpreter(void) {
}

void SimpleMotionInterpreter::AddJointCommands(std::vector<JointState > gotojoints) {
    for (size_t i = 0; i < gotojoints.size(); i++) {
        RCS::CanonCmd newcc;
        newcc.crclcommand = CanonCmdType::CANON_MOVE_JOINT;
        newcc.status = CanonStatusType::CANON_WAITING;
        newcc.joints.position = gotojoints[i].position;
#ifdef DEBUG
        std::cout << "New Joint Position " << VectorDump<double>(newcc.joints.position).c_str();
#endif
        newcc.joints.velocity = gotojoints[i].velocity;
        newcc.joints.effort = gotojoints[i].effort;
        Cnc.robotcmds.AddMsgQueue(newcc);
    }
}

std::vector<JointState> SimpleMotionInterpreter::PlanCartesianMotion(std::vector<RCS::Pose> poses) {
    std::vector<JointState> gotojoints;
    if (poses.size() == 0)
        return gotojoints;
#ifdef DEBUG
    std::cout << "Current Pose " << DumpPose(poses[0]).c_str();
    std::cout << "Goal Pose " << DumpPose(poses[poses.size() - 1]).c_str();

    for (size_t i = 0; i < poses.size(); i++) {
        std::cout << "CartesianMotion  Poses " << DumpPose(poses[i]).c_str();
    }
#endif
    if (RCS::Cnc.eCartesianMotionPlanner == RCS::CController::MOVEIT) {
#ifdef MOVEITPLANNER
        if (RCS::Cnc.MoveitPlanner()->Plan(poses)) {
            gotojoints = RCS::Cnc.MoveitPlanner()->GetJtsPlan();
            return gotojoints;
        }

        // assume first one is where were are already
        for (size_t j = 1; j < poses.size(); j++) {
            if (RCS::Cnc.MoveitPlanner()->Plan(poses[j - 1], poses[j])) {
                std::vector<JointState> intermedjoints;
                intermedjoints = RCS::Cnc.MoveitPlanner()->GetJtsPlan();
                gotojoints.insert(gotojoints.end(), intermedjoints.begin(), intermedjoints.end());
            }
        }
#endif
#ifdef DEBUG
        std::cout << "*******CARTESIAN MOVE TO POSE******\n";
        for (size_t k = 0; k < gotojoints.size(); k++) {
            std::cout << VectorDump<double> (gotojoints[k].position);
        }
#endif
        return gotojoints;

    } else // if (RCS::Cnc.eCartesianMotionPlanner == RCS::CController::WAYPOINT) {
    {
#ifdef MOVEITKIN
        std::vector<double> oldjoints = RCS::Controller.status.currentjoints.position;
        for (size_t i = 0; i < poses.size(); i++) {

            //RCS::Cnc.Kinematics()->SetJointValues(oldjoints);
            std::vector<double> joints = RCS::Cnc.Kinematics()-> IK(poses[i], oldjoints);
#ifdef DEBUG
            std::cout << "GotoPose " << DumpPose(poses[i]).c_str();
            std::cout << "New Joints " << VectorDump<double>(joints).c_str();
#endif
            gotojoints.push_back(EmptyJointState(joints.size()));
            gotojoints.back().position = joints;
            oldjoints = joints;
        }
#endif
        return gotojoints;
    }
}

int SimpleMotionInterpreter::ParseCommand(RCS::CanonCmd cc) {
    //   IfDebug(Globals.ErrorMessage("SimpleMotionInterpreter::ParseCommand\n"));

    // This approach should debounce multiple commands to same position - e.g., 0->30, 0->30
    JointState currentjoints;
    RCS::Pose currentpose; // = RCS::Controller.status.currentpose;

    //RCS::CanonCmd lastrobotcmd = Cnc.GetLastRobotCommand();
    currentjoints = RCS::Cnc.GetLastJointState(); //  open loop - "not actual"
    currentpose = RCS::Cnc.Kinematics()->FK(currentjoints.position);
#ifdef HEAVYDEBUG
    std::cout << "Current Joints " << VectorDump<double>(currentjoints.position).c_str();
    std::cout << "Current Pose " << DumpPose(currentpose).c_str();
#endif
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // SET GRIPPERTS
    if (cc.crclcommand == CanonCmdType::CANON_SET_GRIPPER) {
        RCS::CanonCmd newcc = cc;
        //newcc.crclcommand = CanonCmdType::CANON_SET_GRIPPER;
        //newcc.eepercent=cc.eepercent;
        newcc.status = CanonStatusType::CANON_WAITING;
        Cnc.robotcmds.AddMsgQueue(newcc);
    }        ////////////////////////////////////////////////////////////////////////////////////////////////
        // MOVE JOINTS
    else if (cc.crclcommand == CanonCmdType::CANON_MOVE_JOINT) {
        rates = IRate(DEFAULT_JOINT_MAX_VEL, DEFAULT_JOINT_MAX_ACCEL, DEFAULT_LOOP_CYCLE);

        JointState joints;
        for (size_t i = 0; i < currentjoints.position.size(); i++) {
            joints.position.push_back(currentjoints.position[i]);
            joints.velocity.push_back(DEFAULT_JOINT_MAX_VEL);
            joints.effort.push_back(DEFAULT_JOINT_MAX_ACCEL);
        }

        std::vector<double> maxvel;
        std::vector<double> maxacc;
        // Check each joint, to see if joint is being actuated, if so, change goal position
        for (size_t i = 0; i < cc.jointnum.size(); i++) {
            size_t n = cc.jointnum[i];
            joints.position[n] = cc.joints.position[n]; // joint numbers already adjusted from CRCL to rcs model
            joints.velocity[n] = cc.joints.velocity[n];
            joints.effort[n] = cc.joints.effort[n];
            maxvel.push_back(cc.joints.velocity[n]);
            maxacc.push_back(cc.joints.effort[n]);
        }
        // not sure what happends if no elements in maxvel or maxacc... - should never happen
        double jointsmaxvel = *(std::min_element(std::begin(maxvel), std::end(maxvel)));
        double jointsmaxacc = *(std::min_element(std::begin(maxacc), std::end(maxacc)));
#ifdef HEAVYDEBUG
        std::cout << "Updated Joints Position " << VectorDump<double>(joints.position).c_str();
        std::cout << "Updated Joints Velocity " << VectorDump<double>(joints.velocity).c_str();
        std::cout << "Updated Joints Effort " << VectorDump<double>(joints.effort).c_str();
#endif
        std::vector<JointState > gotojoints;

        if (RCS::Cnc.eJointMotionPlanner == RCS::CController::WAYPOINT) {
            gotojoints = motioncontrol.computeCoorindatedWaypoints(currentjoints.position, joints.position, 0.001, true);
        } else if (RCS::Cnc.eJointMotionPlanner == RCS::CController::BASIC) {
            TrajectoryMaker maker;
            maker.Rates().CurrentFeedrate() = jointsmaxvel;
            maker.Rates().MaximumAccel() = jointsmaxacc;
            maker.setRates(rates);
            maker.makeJointPositionTrajectory(rates, currentjoints.position, joints.position);
            gotojoints = maker.GetJtsPlan();
        }
#ifdef MOVEITPLANNER
        else if (RCS::Cnc.eJointMotionPlanner == RCS::CController::MOVEIT) {
            if (!RCS::Cnc.MoveitPlanner()->Plan(joints))
                return -1;
            gotojoints = RCS::Cnc.MoveitPlanner()->GetJtsPlan();
        }
#endif
        else {
            gotojoints = motioncontrol.computeCoorindatedWaypoints(currentjoints.position, joints.position, 0.001, true);
        }
        if (cc.bCoordinated) {
            AddJointCommands(gotojoints);
        } else {
            // uncoordinated motion - 1st 0 joint, then 1 joint motion, etc.
            // unlikely to crash into itself with this joint motion
            for (size_t k = 0; k < currentjoints.position.size(); k++) {
                JointState eachjoint;
                eachjoint.position = currentjoints.position;
                eachjoint.position[k] = joints.position[k];
                TrajectoryMaker maker;
                maker.Rates().CurrentFeedrate() = jointsmaxvel;
                maker.Rates().MaximumAccel() = jointsmaxacc;
                maker.setRates(rates);
                maker.makeJointPositionTrajectory(rates, currentjoints.position, eachjoint.position);
                gotojoints = maker.GetJtsPlan();
                AddJointCommands(gotojoints);
            }
        }
    }////////////////////////////////////////////////////////////////////////////////////////////////
        // STOP MOTION
    else if (cc.crclcommand == CanonCmdType::CANON_STOP_MOTION) {
        std::vector<std::vector<double> > displacements(status.currentjoints.velocity.size(), std::vector<double>());
        cc.jointnum.clear();

        // clear motion queue   - we are stopping asap!
        robotcmds.ClearMsgQueue();
    }////////////////////////////////////////////////////////////////////////////////////////////////
        // MOVE CARTESIAN
    else if (cc.crclcommand == CanonCmdType::CANON_MOVE_TO) {

        rates = cc.Rates(); // IRate(DEFAULT_CART_MAX_VEL, DEFAULT_CART_MAX_ACCEL, DEFAULT_LOOP_CYCLE);
        RCS::Pose goalpose;
        tf::poseMsgToTF(cc.finalpose, goalpose);
#ifdef MOVEITKIN
        if (RCS::Cnc.Kinematics()->IsSingular(goalpose, 0.0001)) {
            std::cout << "Is singular pose: " << DumpPose(goalpose).c_str();
        }
#endif
        std::vector<JointState> gotojoints;
        std::cout << "Current Pose " << DumpPose(currentpose).c_str();
        std::vector<RCS::Pose> poses = motioncontrol.computeWaypoints(currentpose, goalpose,
                0.01, // cc.Rates().CurrentFeedrate() * DEFAULT_LOOP_CYCLE, //0.01, 
                true);
        for (size_t k = 0; k < poses.size(); k++)
            std::cout << "\n\nWaypoint[" << k << "]" << DumpPose(poses[k]).c_str();

        gotojoints = PlanCartesianMotion(poses);
        AddJointCommands(gotojoints);
    } else if (cc.crclcommand == CanonCmdType::CANON_MOVE_THRU) {
        rates = IRate(DEFAULT_CART_MAX_VEL, DEFAULT_CART_MAX_ACCEL, DEFAULT_LOOP_CYCLE);
        std::vector<JointState> gotojoints;
        // FIXME: waypoints must have a point!
        std::vector<RCS::Pose> poses(sizeof (cc.waypoints) / sizeof (cc.waypoints[0]));
        poses.insert(poses.begin(), currentpose); // add beginning pose -again?
        // and in case interrupted
        gotojoints = PlanCartesianMotion(poses);
        AddJointCommands(gotojoints);
    } else if (cc.crclcommand == CanonCmdType::CANON_DWELL) {
        // wait here or at robot command thread?
        // Could just copy over command to robot
        RCS::CanonCmd newcc;
        newcc.crclcommand = CanonCmdType::CANON_DWELL;
        newcc.status = CanonStatusType::CANON_WAITING;
        newcc.dwell_seconds = cc.dwell_seconds;
        Cnc.robotcmds.AddMsgQueue(newcc);
    }
    return 0;
}
#endif