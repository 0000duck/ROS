.TH "RCS::CMsgQueueThread< T >" 3 "Wed Sep 28 2016" "CRCL FANUC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RCS::CMsgQueueThread< T > \- 
.PP
\fBCMsgQueueThread\fP is a message queued thread\&. It is activated when a message is received\&. 
.br
 Notes: http://stackoverflow.com/questions/768351/complete-example-using-boostsignals-for-c-eventing\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <RCSMsgQueueThread\&.h>\fP
.PP
Inherits \fBRCS::CMessageQueue< T >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCMsgQueueThread\fP ()"
.br
.RI "\fIConstructor of thread, that takes cycle time as input\&. \fP"
.ti -1c
.RI "\fB~CMsgQueueThread\fP ()"
.br
.RI "\fIDestructor of thread, makes sure thread has stopped\&. \fP"
.ti -1c
.RI "virtual void \fBAddMsgQueue\fP (T t)"
.br
.ti -1c
.RI "std::string & \fBName\fP ()"
.br
.RI "\fIName returns name of thread\&. \fP"
.ti -1c
.RI "void \fBJoin\fP ()"
.br
.RI "\fIUses boost thread join routine\&. \fP"
.ti -1c
.RI "virtual void \fBInit\fP ()"
.br
.RI "\fIInit function called before \fBAction()\fP loop\&. \fP"
.ti -1c
.RI "virtual void \fBCleanup\fP ()"
.br
.RI "\fICleanup function called after \fBAction()\fP loop done\&. \fP"
.ti -1c
.RI "virtual int \fBAction\fP ()"
.br
.RI "\fIAction override function called every cycle\&. \fP"
.ti -1c
.RI "void \fBStart\fP ()"
.br
.RI "\fIStart starts the thread which call \fBInit()\fP, and then does \fBAction()\fP loop\&. \fP"
.ti -1c
.RI "void \fBStop\fP (bool bWait=false)"
.br
.RI "\fIStop stops the thread, by notifying the wait condition\&. \fP"
.ti -1c
.RI "void \fBSuspend\fP ()"
.br
.RI "\fISuspend stops the thread loop until restarted with \fBResume()\fP\&. \fP"
.ti -1c
.RI "void \fBResume\fP ()"
.br
.RI "\fIResume resume execution of the thread loop stopped with \fBSuspend()\fP\&. \fP"
.ti -1c
.RI "int & \fBDebugLevel\fP ()"
.br
.RI "\fIDebugLevel returns the debugging level of the thread\&. \fP"
.ti -1c
.RI "void \fBCycle\fP ()"
.br
.RI "\fICycle is the thread main function\&. It calls init, action, and cleanup\&. After each cycle waits exactly amount given by cycle time\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static boost::thread_group & \fBThreadGroup\fP ()"
.br
.RI "\fIThreadGroup is a static definition of boost thread group\&. \fP"
.ti -1c
.RI "static std::vector
.br
< \fBCMsgQueueThread\fP * > & \fBThreads\fP ()"
.br
.RI "\fIThreads is a static definition of all the threads that have been created\&. \fP"
.ti -1c
.RI "static void \fBStopAll\fP ()"
.br
.RI "\fIStatic StopAll which stops all the threads created in the boost thread group\&. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::string \fB_name\fP"
.br
.ti -1c
.RI "int \fB_debugLevel\fP"
.br
.ti -1c
.RI "bool \fB_bDone\fP"
.br
.ti -1c
.RI "boost::thread \fBm_thread\fP"
.br
.ti -1c
.RI "boost::signals2::signal< int()> \fBSigAction\fP"
.br
.ti -1c
.RI "boost::mutex \fBm\fP"
.br
.ti -1c
.RI "boost::mutex \fBstopMutex\fP"
.br
.ti -1c
.RI "boost::condition \fBstopCond\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 

.SS "template<typename T>class RCS::CMsgQueueThread< T >"
\fBCMsgQueueThread\fP is a message queued thread\&. It is activated when a message is received\&. 
.br
 Notes: http://stackoverflow.com/questions/768351/complete-example-using-boostsignals-for-c-eventing\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T > \fBRCS::CMsgQueueThread\fP< T >::\fBCMsgQueueThread\fP ()\fC [inline]\fP"

.PP
Constructor of thread, that takes cycle time as input\&. 
.SS "template<typename T > \fBRCS::CMsgQueueThread\fP< T >::~\fBCMsgQueueThread\fP ()\fC [inline]\fP"

.PP
Destructor of thread, makes sure thread has stopped\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename T > virtual int \fBRCS::CMsgQueueThread\fP< T >::Action ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Action override function called every cycle\&. 
.SS "template<typename T > virtual void \fBRCS::CMsgQueueThread\fP< T >::AddMsgQueue (Tt)\fC [inline]\fP, \fC [virtual]\fP"

.SS "template<typename T > virtual void \fBRCS::CMsgQueueThread\fP< T >::Cleanup ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Cleanup function called after \fBAction()\fP loop done\&. 
.SS "template<typename T > void \fBRCS::CMsgQueueThread\fP< T >::Cycle ()\fC [inline]\fP"

.PP
Cycle is the thread main function\&. It calls init, action, and cleanup\&. After each cycle waits exactly amount given by cycle time\&. 
.SS "template<typename T > int& \fBRCS::CMsgQueueThread\fP< T >::DebugLevel ()\fC [inline]\fP"

.PP
DebugLevel returns the debugging level of the thread\&. 
.PP
\fBReturns:\fP
.RS 4
int returns debug dlvel of thread\&. 
.RE
.PP

.SS "template<typename T > virtual void \fBRCS::CMsgQueueThread\fP< T >::Init ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Init function called before \fBAction()\fP loop\&. 
.SS "template<typename T > void \fBRCS::CMsgQueueThread\fP< T >::Join ()\fC [inline]\fP"

.PP
Uses boost thread join routine\&. 
.SS "template<typename T > std::string& \fBRCS::CMsgQueueThread\fP< T >::Name ()\fC [inline]\fP"

.PP
Name returns name of thread\&. 
.SS "template<typename T > void \fBRCS::CMsgQueueThread\fP< T >::Resume ()\fC [inline]\fP"

.PP
Resume resume execution of the thread loop stopped with \fBSuspend()\fP\&. 
.SS "template<typename T > void \fBRCS::CMsgQueueThread\fP< T >::Start ()\fC [inline]\fP"

.PP
Start starts the thread which call \fBInit()\fP, and then does \fBAction()\fP loop\&. 
.SS "template<typename T > void \fBRCS::CMsgQueueThread\fP< T >::Stop (boolbWait = \fCfalse\fP)\fC [inline]\fP"

.PP
Stop stops the thread, by notifying the wait condition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbWait\fP indicates whether to wait until thread has finished\&. 
.RE
.PP

.SS "template<typename T > static void \fBRCS::CMsgQueueThread\fP< T >::StopAll ()\fC [inline]\fP, \fC [static]\fP"

.PP
Static StopAll which stops all the threads created in the boost thread group\&. 
.SS "template<typename T > void \fBRCS::CMsgQueueThread\fP< T >::Suspend ()\fC [inline]\fP"

.PP
Suspend stops the thread loop until restarted with \fBResume()\fP\&. 
.SS "template<typename T > static boost::thread_group& \fBRCS::CMsgQueueThread\fP< T >::ThreadGroup ()\fC [inline]\fP, \fC [static]\fP"

.PP
ThreadGroup is a static definition of boost thread group\&. 
.SS "template<typename T > static std::vector<\fBCMsgQueueThread\fP *>& \fBRCS::CMsgQueueThread\fP< T >::Threads ()\fC [inline]\fP, \fC [static]\fP"

.PP
Threads is a static definition of all the threads that have been created\&. 
.SH "Member Data Documentation"
.PP 
.SS "template<typename T > bool \fBRCS::CMsgQueueThread\fP< T >::_bDone\fC [protected]\fP"
boolean indicating whether thread has finished 
.SS "template<typename T > int \fBRCS::CMsgQueueThread\fP< T >::_debugLevel\fC [protected]\fP"
debug level of thread 
.SS "template<typename T > std::string \fBRCS::CMsgQueueThread\fP< T >::_name\fC [protected]\fP"
name of thread 
.SS "template<typename T > boost::mutex \fBRCS::CMsgQueueThread\fP< T >::m\fC [protected]\fP"
mutex for signal new message 
.SS "template<typename T > boost::thread \fBRCS::CMsgQueueThread\fP< T >::m_thread\fC [protected]\fP"
boost thread 
.SS "template<typename T > boost::signals2::signal<int ()> \fBRCS::CMsgQueueThread\fP< T >::SigAction\fC [protected]\fP"
signals action method 
.SS "template<typename T > boost::condition \fBRCS::CMsgQueueThread\fP< T >::stopCond\fC [protected]\fP"
condition for stopping 
.SS "template<typename T > boost::mutex \fBRCS::CMsgQueueThread\fP< T >::stopMutex\fC [protected]\fP"
mutex for stopping 

.SH "Author"
.PP 
Generated automatically by Doxygen for CRCL FANUC from the source code\&.
