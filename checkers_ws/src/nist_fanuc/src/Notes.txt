

#if 0
        // wait till move  done...
        while (robot.cnc()->crclcmds.SizeMsgQueue() > 0) // wait till nothing left or messes up timing
            ros::Duration(0.01).sleep();
        while (robot.cnc()->robotcmds.SizeMsgQueue() > 0) // canon cmds are translated into robot cmds
            ros::Duration(0.01).sleep();
#else
===========================================================

Condition signaling with boost

    boost::mutex kdlMutex; /**< mutex for stopping */
    boost::condition kdlCond; /**< condition for stopping */

 //           kdlCond.notify_all();

missing code for waiting for signal .... (deleted :()
==========================================================
This is useful for computing gripper offset ( sort of - since full length not captured)
extern RCS::Pose ComputeGripperOffset();
extern RCS::Pose AutoComputeGripperOffset(urdf::Model& robot_model, std::string prefix);


         ComputeGripperOffset();
#ifdef FANUCPREFIX
        AutoComputeGripperOffset(fkin->armkin->robot_model, "fanuc_");
#else
        AutoComputeGripperOffset(fkin->armkin->robot_model, "");
#endif

==========================================================
THis is for single threaded robot control:
        while (RCS::Mnc->IsBusy()) {

            RCS::Mnc->Action();
        }
==========================================================

#define ARMKIN
#ifdef ARMKIN
 #ifdef FANUCPREFIX
#else
        fkin = boost::shared_ptr<IKinematics>(new ArmKinematics("", "link_6", "base_link"));
#endif
        // Initialization of Controller instantiation of shared objects  
        // Fixme: there is no tool0?
        //  rosparam tip_name=	"fanuc_link_6" root_name"="world" 
 
//        boost::shared_ptr<IKinematics> mkin;
//        mkin = boost::shared_ptr<IKinematics>(new ArmKinematics("motoman_", motomanbaseoffset));
//        mkin->Init(std::string("manipulator"), std::string("motoman_link_t"), std::string("motoman_base_link"));
//        // mkin->Init(std::string("manipulator"), std::string("motoman_link_t"),std::string("world"));
//        mkin->Init(nh);

#endif

#else
        RCS::Fnc->Setup(nh, "");
//        RCS::Fnc->status.Init();
#endif

==========================================================

6.0 ikfast
#include "Motoman/ikfast.h"
#include <algorithm>
using namespace  ikfast;
class FastKinematics : public IKinematics {

    static double SIGN(double x) {
        return ( x >= 0.0f) ? +1.0f : -1.0f;
    }

    static double NORM(double a, double b, double c, double d) {
        return sqrt(a * a + b * b + c * c + d * d);
    }
    // Convert rotation matrix to quaternion (Daisuke Miyazaki)
    // http://pastebin.com/NikwbL3k

    static RCS::Rotation Convert2Rotation(IkReal *eerot) {
        double q0 = (eerot[0] + eerot[4] + eerot[8] + 1.0f) / 4.0f;
        double q1 = (eerot[0] - eerot[4] - eerot[8] + 1.0f) / 4.0f;
        double q2 = (-eerot[0] + eerot[4] - eerot[8] + 1.0f) / 4.0f;
        double q3 = (-eerot[0] - eerot[4] + eerot[8] + 1.0f) / 4.0f;

        if (q0 < 0.0f) {
            q0 = 0.0f;
        }

        if (q1 < 0.0f) {
            q1 = 0.0f;
        }

        if (q2 < 0.0f) {
            q2 = 0.0f;
        }

        if (q3 < 0.0f) {
            q3 = 0.0f;
        }
        q0 = sqrt(q0);
        q1 = sqrt(q1);
        q2 = sqrt(q2);
        q3 = sqrt(q3);

        if ((q0 >= q1) && (q0 >= q2) && (q0 >= q3)) {
            q0 *= +1.0f;
            q1 *= SIGN(eerot[7] - eerot[5]);
            q2 *= SIGN(eerot[2] - eerot[6]);
            q3 *= SIGN(eerot[3] - eerot[1]);
        } else if ((q1 >= q0) && (q1 >= q2) && (q1 >= q3)) {
            q0 *= SIGN(eerot[7] - eerot[5]);
            q1 *= +1.0f;
            q2 *= SIGN(eerot[3] + eerot[1]);
            q3 *= SIGN(eerot[2] + eerot[6]);
        } else if ((q2 >= q0) && (q2 >= q1) && (q2 >= q3)) {
            q0 *= SIGN(eerot[2] - eerot[6]);
            q1 *= SIGN(eerot[3] + eerot[1]);
            q2 *= +1.0f;
            q3 *= SIGN(eerot[7] + eerot[5]);
        } else if ((q3 >= q0) && (q3 >= q1) && (q3 >= q2)) {
            q0 *= SIGN(eerot[3] - eerot[1]);
            q1 *= SIGN(eerot[6] + eerot[2]);
            q2 *= SIGN(eerot[7] + eerot[5]);
            q3 *= +1.0f;
        } else {
            throw std::runtime_error("Error while converting to quaternion! \n");
        }
        double r = NORM(q0, q1, q2, q3);
        q0 /= r;
        q1 /= r;
        q2 /= r;
        q3 /= r;
        RCS::Rotation q(q0, q1, q2, q3);
        return q;
    }
    // Convert input effector pose, in w x y z quaternion notation, to rotation matrix.
    // Must use doubles, else lose precision compared to directly inputting the rotation matrix.
    // Found at http://kaist-ros-pkg.googlecode.com/svn/trunk/arm_kinematics_tools/src/ikfastdemo/ikfastdemo.cpp

    static void Convert2RotationMatrix(const RCS::Rotation & quat, IkReal *eerot) {
        double qq1 = 2 * quat.x() * quat.x();
        double qq2 = 2 * quat.y() * quat.y();
        double qq3 = 2 * quat.z() * quat.z();
        eerot[3 * 0 + 0] = 1 - qq2 - qq3;
        eerot[3 * 0 + 1] = 2 * (quat.x() * quat.y() - quat.w() * quat.z());
        eerot[3 * 0 + 2] = 2 * (quat.x() * quat.z() + quat.w() * quat.y());
        eerot[3 * 1 + 0] = 2 * (quat.x() * quat.y() + quat.w() * quat.z());
        eerot[3 * 1 + 1] = 1 - qq1 - qq3;
        eerot[3 * 1 + 2] = 2 * (quat.y() * quat.z() - quat.w() * quat.x());
        eerot[3 * 2 + 0] = 2 * (quat.x() * quat.z() - quat.w() * quat.y());
        eerot[3 * 2 + 1] = 2 * (quat.y() * quat.z() + quat.w() * quat.x());
        eerot[3 * 2 + 2] = 1 - qq1 - qq2;
    }
public:

    virtual RCS::Pose FK(std::vector<double> jv) {
        // Handle gearing of joints
        std::vector<double> joints;
        joints.insert(joints.begin(), jv.begin(), jv.end());
        //joints(1) = thetas[1] - M_PI_2;
        joints[2] += jv[1];

        // IkReal j[6]={ 0.0, 0.0, 0.0, 0.0, 0.0};
        IkReal eetrans[4];
        IkReal eerot[9];

        // / Computes the end effector coordinates given the joint values using ikfast. This function is used to double check ik
        // Units? joint angles in radians or degree
        // Elsewhere: Returns the forward kinematic solution given the joint angles (in radians)
        ComputeFk(&joints[0], eetrans, eerot);

        RCS::Pose pose;
        pose.getOrigin().setX(eetrans[0]);
        pose.getOrigin().setY(eetrans[1]);
        pose.getOrigin().setZ(eetrans[2]);
        pose.setRotation(Convert2Rotation(eerot));
        return pose;
    }
    // http://docs.ros.org/jade/api/moveit_msgs/html/msg/PositionIKRequest.html
    //http://docs.ros.org/hydro/api/ric_mc/html/GetPositionIK_8h_source.html

    virtual size_t AllPoseToJoints(RCS::Pose & pose, std::vector<std::vector<double>> &joints) {
        // Inverse kinematics
        ikfast::IkSolutionList<IkReal> solutions;

        std::vector<IkReal> vfree(GetNumFreeParameters());
        IkReal eetrans[3] = {pose.getOrigin().x(), pose.getOrigin().y(), pose.getOrigin().z()}; // + .33};

        IkReal eerot[9];
        Convert2RotationMatrix(pose.getRotation(), eerot);
#ifdef DEBUG
        std::cout << Globals.StrFormat("IKFAST IK\n");
        std::cout << Globals.StrFormat("Pos  X=%6.4f Y=%6.4f Z=%6.4f\n", eetrans[0], eetrans[1], eetrans[2]);
        std::cout << Globals.StrFormat("XROT I=%6.4f J=%6.4f K=%6.4f\n", eerot[0], eerot[1], eerot[2]);
        std::cout << Globals.StrFormat("ZROT I=%6.4f J=%6.4f K=%6.4f\n", eerot[6], eerot[7], eerot[8]);
#endif
        bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

        if (!bSuccess) {
            std::cerr << Globals.StrFormat("Failed to get ik solution\n");
            return -1;
        }

        // There are no redundant joints, so no free dof

        std::cerr << Globals.StrFormat("Found %d ik solutions:\n", (int) solutions.GetNumSolutions());
        std::vector<IkReal> solvalues(GetNumJoints());

        for (std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
            const ikfast::IkSolutionBase<IkReal> & sol = solutions.GetSolution(i);

#ifdef DEBUG
            std::cerr << Globals.StrFormat("sol%d (free=%d): ", (int) i, (int) sol.GetFree().size());
#endif
            std::vector<IkReal> vsolfree(sol.GetFree().size());
            sol.GetSolution(&solvalues[0], vsolfree.size() > 0 ? &vsolfree[0] : NULL);

#ifdef DEBUG
            for (std::size_t j = 0; j < solvalues.size(); ++j) {
                std::cerr << Globals.StrFormat("%6.4f, ", Rad2Deg(solvalues[j]));
            }
            std::cerr << Globals.StrFormat("\n");
#endif

            std::vector<double> jnts;

            for (std::size_t j = 0; j < solvalues.size(); ++j) {
                jnts.push_back(solvalues[j]);
            }
            jnts[2] -= jnts[1];
            joints.push_back(jnts);
        }
        return solutions.GetNumSolutions();
    }

    Eigen::VectorXd ConvertJoints(std::vector<double> v) {
        Eigen::VectorXd p(v.size());
        for (size_t i = 0; i < v.size(); i++)
            p(i) = v[i];
        return p;
    }

    std::vector<double> ConvertJoints(Eigen::VectorXd ev) {
        std::vector<double> v;
        for (int i = 0; i < ev.size(); i++)
            v.push_back(ev(i));
        return v;
    }

    virtual std::vector<double> NearestJoints(
            std::vector<double> oldjoints,
            std::vector<std::vector<double>> &newjoints) {
        std::vector<double> finaljoints;
        Eigen::VectorXd oldjointvec = ConvertJoints(oldjoints);
        double min = std::numeric_limits<double>::infinity();
        size_t index = 0;
        for (size_t i = 0; i < newjoints.size(); i++) {
            Eigen::VectorXd newjointvec = ConvertJoints(newjoints[i]);
            double diff = (oldjointvec - newjointvec).norm();
            if (diff < min) {
                min = diff;
                index = i;
            }
        }
        // save "best" solution - closset ignoring importance of wrist
        finaljoints.insert(finaljoints.begin(), newjoints[index].begin(), newjoints[index].end());
        return finaljoints;
    }

    virtual std::vector<double> IK(RCS::Pose & pose,
            std::vector<double> oldjoints) {
        std::vector<std::vector<double>> allsolutions;
        size_t bFlag = AllPoseToJoints(pose, allsolutions);

        return NearestJoints(oldjoints, allsolutions);
        //response.error_code.val == response.error_code.SUCCES
        //return response.solution.joint_state.position;
    }

    virtual std::vector<double> IK(RCS::Pose & pose,
            std::vector<double> minrange, std::vector<double> maxrange) {
        std::vector<std::vector<double>> allsolutions;
        size_t bFlag = AllPoseToJoints(pose, allsolutions);
        for (size_t i = 0; i < allsolutions.size(); i++) {
            bool bFlag = true;
            for (size_t j = 0; j < allsolutions[0].size(); j++) {
                if (allsolutions[i][j] < minrange[j] || allsolutions[i][j] > maxrange[j])
                    bFlag = false;
            }
            if (bFlag)
                return allsolutions[i];

        }
        // just pick one
        size_t n = rand() % allsolutions.size();
        return allsolutions[n];
    }


    virtual bool IsSingular(RCS::Pose & pose, double threshold) {
        return false;
    }

    virtual void Init(ros::NodeHandle &nh) {
        armkin = boost::shared_ptr<::Kinematics>(new ::Kinematics());
        armkin->init(nh, _tiplinkname, _rootlinkname);
        moveit_msgs::GetKinematicSolverInfo::Request request;
        moveit_msgs::GetKinematicSolverInfo::Response response;
        armkin->getFKSolverInfo(request, response);
        joint_names.clear();
        link_names.clear();
        num_joints = response.kinematic_solver_info.joint_names.size();
        for (unsigned int i = 0; i < response.kinematic_solver_info.joint_names.size(); i++) {
            joint_names.push_back(response.kinematic_solver_info.joint_names[i]);
        }
        for (unsigned int i = 0; i < response.kinematic_solver_info.link_names.size(); i++) {
            link_names.push_back(response.kinematic_solver_info.link_names[i]);
        }
        for (int i = 0; i < armkin->joint_min.rows(); i++)
            joint_min.push_back(armkin->joint_min(i));
        for (int i = 0; i < armkin->joint_max.rows(); i++)
            joint_max .push_back(armkin->joint_max(i));
    }

    void VerifyLimits(std::vector<double> joints) {
        for (size_t i = 0; i < joints.size(); i++)
            if (joints[i] < joint_min[i] || joints[i] > joint_max[i])
                ROS_ERROR_STREAM("Verify Joint Limits Joint" << joint_names[i] << "out of range");

    }
    virtual std::vector<double> FindBoundedSolution(std::vector<std::vector<double>> &solutions,
            std::vector<double> &min,
            std::vector<double> &max);

};
#include "fanuc_lrmate200id.h"

class FanucLrMate200idKinematics : public IKinematics {
    fanuc_lrmate200id fanuckin;
    tf::Pose base;
public:

    FanucLrMate200idKinematics() {
        base = tf::Pose(tf::Quaternion(0, 0, 0, 1),
                tf::Vector3(0.0, 0.0, 0.330));
    }

    virtual RCS::Pose FK(std::vector<double> jv) {

        tf::Pose pose = fanuckin.fanuc_lrmate200id_kin_fwd(&jv[0]);
        return base*pose;
        //return pose;
    }

    virtual std::vector<double> IK(RCS::Pose & pose,
            std::vector<double> oldjoints) {
        tf::Pose base(tf::Quaternion(0, 0, 0, 1),
                tf::Vector3(0.0, 0.0, 0.330));
        pose = base.inverse() * pose;
        std::vector<double> joints = fanuckin.fanuc_lrmate200id_kin_inv(pose);
        return joints;
    }

    virtual size_t AllPoseToJoints(RCS::Pose & pose,
            std::vector<std::vector<double> > & newjoints) {
        return 0;
    }

    virtual std::vector<double> NearestJoints(
            std::vector<double> oldjoints,
            std::vector<std::vector<double> > & newjoints) {
        ROS_ERROR("FanucLrMate200idKinematics::NearestJoints() not implemented");
        return std::vector<double>();
    }

    virtual void Init(ros::NodeHandle &nh) {
        armkin = boost::shared_ptr<::Kinematics>(new ::Kinematics());
        armkin->init(nh, _tiplinkname, _rootlinkname);
        moveit_msgs::GetKinematicSolverInfo::Request request;
        moveit_msgs::GetKinematicSolverInfo::Response response;
        armkin->getFKSolverInfo(request, response);
        joint_names.clear();
        link_names.clear();
        num_joints = response.kinematic_solver_info.joint_names.size();
        for (unsigned int i = 0; i < response.kinematic_solver_info.joint_names.size(); i++) {
            joint_names.push_back(response.kinematic_solver_info.joint_names[i]);
        }
        for (unsigned int i = 0; i < response.kinematic_solver_info.link_names.size(); i++) {
            link_names.push_back(response.kinematic_solver_info.link_names[i]);
        }
    }



};
//////////////////////////////////////////////////////////////////////////////////
Bang bang no interpretation

#ifdef FEEDBACKTEST
                Cnc.status.echocmd = cc; /**<  copy of current command */
                Cnc.status.currentjoints = Cnc.Kinematics()->UpdateJointState(cc.jointnum, Controller.status.currentjoints, cc.joints);
                Cnc.status.currentpose = Cnc.Kinematics()->FK(Cnc.status.currentjoints.position); /**<  current robot pose */
                Cnc.status.currentjoints.header.stamp = ros::Time(0);
                LOG_DEBUG << "Current Joints " << RCS::VectorDump<double>(Cnc.status.currentjoints.position).c_str();
                rviz_jntcmd.publish(Cnc.status.currentjoints);
#elif defined FEEDBACKTEST2
                Cnc.robotcmds.AddMsgQueue(cc); // ok if not pose
#else   
... REAL CODE                  
#endif
//////////////////////////////////////////////////////////////////////////////////
        {
            joints = ToVector<double>(7, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.0);
            pose = fastkin->FK(joints);
            LOG_DEBUG << "Motoman FK Joints=" << VectorDump<double>(joints).c_str();
            LOG_DEBUG << "Motoman FK Pose=" << RCS::DumpPoseSimple(pose).c_str();
            // Can't be done
            //joints =  mkin->IK(pose, ToVector<double>(7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));           
            joints =  fastkin->IK(pose, ToVector<double>(7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));           
            LOG_DEBUG << "Motoman IK Joints=" << VectorDump<double>(joints).c_str();
            
            LOG_DEBUG << "====================================";
            // -0.0821; -0.147; -0.012
            joints = ToVector<double>(7, 1.64, -1.29, -0.22, 1.56, 0.0, 0.0, 0.0);
            pose =   fastkin->FK(joints);
            LOG_DEBUG << "Motoman FK Joints=" << VectorDump<double>(joints).c_str();
            LOG_DEBUG << "Motoman FK Pose=" << RCS::DumpPoseSimple(motomanbaseoffset * pose).c_str();

            LOG_DEBUG << "Motoman IK Pose=" << RCS::DumpPoseSimple( pose).c_str();
            joints =  mkin->IK(pose, ToVector<double>(7, 1.64, -1.29, -0.22, 1.56, 0.0, 0.0, 0.0));
            //joints =  fastkin->IK(pose, ToVector<double>(7, 1.64, -1.29, -0.22, 1.56, 0.0, 0.0, 0.0));
            //joints =  mkin->IK(motomanbaseoffset * pose, ToVector<double>(7, 1.64, -1.29, -0.22, 1.56, 0.0, 0.0, 0.0));
            LOG_DEBUG << "Motoman IK Joints=" << VectorDump<double>(joints).c_str();
        }
//////////////////////////////////////////////////////////////////////////////////////////
//        LOG_DEBUG << ExecuteShellCommand("env|sort\n");

        // This is useful for rosbag i suppose
        //        std::string run_id;
        //        nh.getParam("run_id", run_id);
        //        std::cout << run_id.c_str() << std::endl;




lrmate200id_macro.xacro

    <joint name="${prefix}joint_6-tool0" type="fixed">
<!--      <origin xyz="0 0 0" rpy="${m_pi} ${-m_pi_2} 0" /> -->
      <origin xyz="0 0 0" rpy="0 0 0" />
     <parent link="${prefix}link_6" />
      <child link="${prefix}robotiq_85_adapter_link" />
     <axis xyz="0 0 0"/> <!-- no rotation -->
    </joint>

  <link name="${prefix}robotiq_85_adapter_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_adapter_plate.dae"/>
      </geometry>
      <origin rpy="1.5707 0 1.5707" xyz="0 0 0"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_adapter_plate.dae"/>
      </geometry>
      <origin rpy="0 0 1.5707" xyz="0 0 0"/>
    </collision>
  </link>

  <!--  /\  -->
  <joint name="${prefix}robotiq_85_base_joint" type="fixed">
    <parent link="${prefix}robotiq_85_adapter_link"/>
    <child link="${prefix}robotiq_85_base_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="0 0 0" xyz=".0085 0 -.0041"/>
  </joint>
  <!--  \/  -->

  <link name="${prefix}robotiq_85_base_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_base.dae"/>
      </geometry>
      <origin rpy="3.1415 0 1.5707" xyz="0 0 0"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_base.dae"/>
      </geometry>
      <origin rpy="1.5707 0 1.5707" xyz="0 0 0"/>
    </collision>
  </link>

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_left_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="-1.5707 1.5707 0" xyz=".04191 .0306 0"/>
    <limit lower="0" upper=".8575" velocity="2.0" effort="1000"/>
  </joint>

  <joint name="${prefix}robotiq_85_right_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_right_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="1.5707 -1.5707 0" xyz=".04191 -.0306 0"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" multiplier="1"/>
  </joint>
  <!--  \/  -->
  <!--  \/  -->

  <link name="${prefix}robotiq_85_left_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_0_L.dae"/>
      </geometry>
      <origin rpy="3.14159 -1.5707 0" xyz="0 .04191 -.0306"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_0_L.dae"/>
      </geometry>
      <origin rpy="1.5707 -1.5707 0" xyz="0 .04191 -.0306"/>
    </collision>
  </link> 

  <link name="${prefix}robotiq_85_right_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_0_R.dae"/>
      </geometry>
      <origin rpy="3.14159 1.5707 0" xyz="0 .04191 -.0306"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_0_R.dae"/>
      </geometry>
      <origin rpy="1.5707 1.5707 0" xyz="0 .04191 -.0306"/>
    </collision>
  </link>

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_finger_joint" type="fixed">
    <parent link="${prefix}robotiq_85_left_knuckle_link"/>
    <child link="${prefix}robotiq_85_left_finger_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="3.1415 0 0" xyz="0 .00508 .03134"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
  </joint>

  <joint name="${prefix}robotiq_85_right_finger_joint" type="fixed">
    <parent link="${prefix}robotiq_85_right_knuckle_link"/>
    <child link="${prefix}robotiq_85_right_finger_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="3.1415 0 0" xyz="0 .00508 .03134"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
  </joint>
  <!--  \/  --> 
  <!--  \/  -->  

  <link name="${prefix}robotiq_85_left_finger_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_1_L.dae"/>
      </geometry>
      <origin rpy="0 1.5707 0" xyz="0 -.03683 .06194"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_1_L.dae"/>
      </geometry>
      <origin rpy="-1.5707 1.5707 0" xyz="0 -.03683 .06194"/>
    </collision>
  </link> 

  <link name="${prefix}robotiq_85_right_finger_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_1_R.dae"/>
      </geometry>
      <origin rpy="0 -1.5707 0" xyz="0 -.03683 .06194"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_1_R.dae"/>
      </geometry>
      <origin rpy="-1.5707 -1.5707 0" xyz="0 -.03683 .06194"/>
    </collision>
  </link> 

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_inner_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_left_inner_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="1.5707 1.5707 0" xyz=".04843 .0127 0"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" offset="0"/>
  </joint> 

  <joint name="${prefix}robotiq_85_right_inner_knuckle_joint" type="revolute">
    <parent link="${prefix}robotiq_85_base_link"/>
    <child link="${prefix}robotiq_85_right_inner_knuckle_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="-1.5707 -1.5707 0" xyz=".04843 -.0127 0"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" offset="0"/>
  </joint>
  <!--  \/  --> 
  <!--  \/  -->  

  <link name="${prefix}robotiq_85_left_inner_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_2_L.dae"/>
      </geometry>
      <origin rpy="0 1.5707 0" xyz="0 -.04843 .0127"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_2_L.dae"/>
      </geometry>
      <origin rpy="-1.5707 1.5707 0" xyz="0 -.04843 .0127"/>
    </collision>
  </link>

  <link name="${prefix}robotiq_85_right_inner_knuckle_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_2_R.dae"/>
      </geometry>
      <origin rpy="0 -1.5707 0" xyz="0 -.04843 .0127"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_2_R.dae"/>
      </geometry>
      <origin rpy="-1.5707 -1.5707 0" xyz="0 -.04843 .0127"/>
    </collision>
  </link>

  <!--  /\  -->
  <!--  /\  -->
  <joint name="${prefix}robotiq_85_left_finger_tip_joint" type="revolute">
    <parent link="${prefix}robotiq_85_left_inner_knuckle_link"/>
    <child link="${prefix}robotiq_85_left_finger_tip_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="0 0 0" xyz="0 .04196 -.0388"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" multiplier="-1"/>
  </joint>

  <joint name="${prefix}robotiq_85_right_finger_tip_joint" type="revolute">
    <parent link="${prefix}robotiq_85_right_inner_knuckle_link"/>
    <child link="${prefix}robotiq_85_right_finger_tip_link"/>
    <axis xyz="1 0 0"/>
    <origin rpy="0 0 0" xyz="0 .04196 -.0388"/>
    <limit lower="0" upper="1.5707" velocity="2.0" effort="1000"/>
    <mimic joint="${prefix}robotiq_85_left_knuckle_joint" multiplier="-1"/>
  </joint>
  <!--  \/  --> 
  <!--  \/  -->  

  <link name="${prefix}robotiq_85_left_finger_tip_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_3_L.dae"/>
      </geometry>
      <origin rpy="0 1.5707 0" xyz="0 -.090381 .051505"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_3_L.dae"/>
      </geometry>
      <origin rpy="-1.5707 1.5707 0" xyz="0 -.090381 .051505"/>
    </collision>
  </link> 

  <link name="${prefix}robotiq_85_right_finger_tip_link">
    <visual>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/visual/robotiq_85_gripper_joint_3_R.dae"/>
      </geometry>
      <origin rpy="0 -1.5707 0" xyz="0 -.090381 .051505"/>
    </visual>
    <collision>
      <geometry>
        <mesh filename="package://fanuc_lrmate200id_support/meshes/robotiq_c2/collision/robotiq_85_gripper_joint_3_R.dae"/>
      </geometry>
      <origin rpy="-1.5707 -1.5707 0" xyz="0 -.090381 .051505"/>
    </collision>
  </link>


   void RvizSetup() {
        tf::Quaternion qidentity(0.0, 0.0, 0.0, 1.0);

        for (size_t row = 0; row < rows; row++) {
            double rowoffset = xoffset + (offset * row);
            for (size_t i = 0; i <= cols; i = i + 2) {
                double coloffset = yoffset + (i * offset);
                if (row % 2 == 0) coloffset = coloffset + offset; // red offset at zero

                Eigen::Vector3d up(rowoffset, coloffset, 0.01);
                Eigen::Vector3d down(rowoffset + offset, coloffset + offset, 0.0);
                std::string sqname = Globals.StrFormat("Square[%d:%d]", row, i);
                ObjectDB * obj = new ObjectDB(sqname,
                        "Checkerboard",
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(up))),
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(down))),
                        rviz_visual_tools::WHITE);
                obj->centroid = Eigen::Vector3d(rowoffset + offset / 2.0, coloffset + offset / 2.0, .01);
                ObjectDB::Save(obj);

                ObjectDB * checker;
                size_t checkercol = (row % 2 == 0) ? i + 1 : i; //  coloffset = coloffset + offset; // red offset at zero
                rviz_visual_tools::colors checkercolor = rviz_visual_tools::CLEAR;
                if (row < 3) checkercolor = rviz_visual_tools::RED;
                if (row >= 5) checkercolor = rviz_visual_tools::BLACK;
                if (checkercolor != rviz_visual_tools::CLEAR) {
                    std::string checkername = Globals.StrFormat("Checker[%d:%d]", row, checkercol);
                    checker = new ObjectDB(checkername,
                            "Cylinder",
                            Eigen::Affine3d(Eigen::Translation3d(obj->centroid)),
                            checkercolor,
                            height,
                            radius ,
                            "Cylinder");
                    ObjectDB::Save(checker);
                }

                if (row % 2 == 0) coloffset = coloffset - offset; // red offset at zero
                else coloffset = coloffset + offset;
                Eigen::Vector3d bup(rowoffset, coloffset, 0.01);
                Eigen::Vector3d bdown(rowoffset + offset, coloffset + offset, 0.0);
                sqname = Globals.StrFormat("Square[%d:%d]", row, i);
                obj = new ObjectDB(sqname,
                        "Checkerboard",
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(bup))),
                        RcsPose2Affine3d(RCS::Pose(qidentity, vectorEigenToTF<Eigen::Vector3d>(bdown))),
                        rviz_visual_tools::BLACK);
                obj->centroid = Eigen::Vector3d(rowoffset + offset / 2.0, coloffset + offset / 2.0, 0.01);
                ObjectDB::Save(obj);
            }
        }
    }


  +---+---+---+---+---+---+---+---+
0 |   | r |   | B |   | r |   | r |
  +---+---+---+---+---+---+---+---+
1 |   |   |   |   |   |   | r |   |
  +---+---+---+---+---+---+---+---+
2 |   |   |   |   |   | r |   |   |
  +---+---+---+---+---+---+---+---+
3 |   |   | r |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
4 |   |   |   |   |   | b |   | b |
  +---+---+---+---+---+---+---+---+
5 |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+
6 |   | b |   | b |   |   |   | b |
  +---+---+---+---+---+---+---+---+
7 | b |   |   |   |   |   | b |   |
  +---+---+---+---+---+---+---+---+
    0   1   2   3   4   5   6   7
#if 0
class SimpleMotionInterpreter: public RCSInterpreter
{
public:
	/*!
	* \brief RCSInterpreter constructor that optionally accepts pointer to kinematic instance.
	\param k is the kinematics pointer
	*/
    SimpleMotionInterpreter(IKinematicsSharedPtr k = NULL);
    ~SimpleMotionInterpreter(void);

	/*!
	* \brief ParseCommand parses a RCS command and queues robot motion commands.
	\param cmd is the command to interpret
	*/
    virtual int ParseCommand(RCS::CanonCmd cmd);
protected:
	/*!
	* \brief AddJointCommands  accepts vector of joint trajectories and adds to robot motion queue.
	\param gotojoints is the vector of joint states describing the motion.
	*/
    void AddJointCommands(std::vector<JointState > gotojoints);

	/*!
	* \brief PlanCartesianMotion accepts vector of poses and generates a vector of joint trajectories.
	* Can use a couple of planning algorithms to generate trajectory.
	\param poses is the vector of cartesian motion.
	\return vector of planned joint states
	*/
    std::vector<JointState> PlanCartesianMotion(std::vector<RCS::Pose> poses);

    //////////////////////////////////////////////////
public:
#ifdef DESCARTES
    TrajectoryVec results; /**< descartes motion planner results */
#endif
    std::vector<double> times;  /**< descartes times for  trajectory results */
    IRate rates; /**< rates structure for simple motion planner  */
    MotionControl motioncontrol; /**< instance of simple motion control object  */
 
};
#endif
#ifdef DESCARTES
using namespace descartes_core;
using namespace descartes_trajectory;
#endif

#if 0
SimpleMotionInterpreter::SimpleMotionInterpreter(IKinematicsSharedPtr pKinematics) {
    _kinematics = pKinematics; // hopefully can be null
    //    _kinematics = IKinematicsSharedPtr(new DummyKinematics());
    rates = IRate(DEFAULT_CART_MAX_VEL, DEFAULT_CART_MAX_ACCEL, DEFAULT_LOOP_CYCLE);
}

SimpleMotionInterpreter::~SimpleMotionInterpreter(void) {
}

void SimpleMotionInterpreter::AddJointCommands(std::vector<JointState > gotojoints) {
    for (size_t i = 0; i < gotojoints.size(); i++) {
        RCS::CanonCmd newcc;
        newcc.crclcommand = CanonCmdType::CANON_MOVE_JOINT;
        newcc.status = CanonStatusType::CANON_WAITING;
        newcc.joints.position = gotojoints[i].position;
#ifdef DEBUG
        std::cout << "New Joint Position " << VectorDump<double>(newcc.joints.position).c_str();
#endif
        newcc.joints.velocity = gotojoints[i].velocity;
        newcc.joints.effort = gotojoints[i].effort;
        Cnc.robotcmds.AddMsgQueue(newcc);
    }
}

std::vector<JointState> SimpleMotionInterpreter::PlanCartesianMotion(std::vector<RCS::Pose> poses) {
    std::vector<JointState> gotojoints;
    if (poses.size() == 0)
        return gotojoints;
#ifdef DEBUG
    std::cout << "Current Pose " << DumpPose(poses[0]).c_str();
    std::cout << "Goal Pose " << DumpPose(poses[poses.size() - 1]).c_str();

    for (size_t i = 0; i < poses.size(); i++) {
        std::cout << "CartesianMotion  Poses " << DumpPose(poses[i]).c_str();
    }
#endif
    if (RCS::Cnc.eCartesianMotionPlanner == RCS::CController::MOVEIT) {
#ifdef MOVEITPLANNER
        if (RCS::Cnc.MoveitPlanner()->Plan(poses)) {
            gotojoints = RCS::Cnc.MoveitPlanner()->GetJtsPlan();
            return gotojoints;
        }

        // assume first one is where were are already
        for (size_t j = 1; j < poses.size(); j++) {
            if (RCS::Cnc.MoveitPlanner()->Plan(poses[j - 1], poses[j])) {
                std::vector<JointState> intermedjoints;
                intermedjoints = RCS::Cnc.MoveitPlanner()->GetJtsPlan();
                gotojoints.insert(gotojoints.end(), intermedjoints.begin(), intermedjoints.end());
            }
        }
#endif
#ifdef DEBUG
        std::cout << "*******CARTESIAN MOVE TO POSE******\n";
        for (size_t k = 0; k < gotojoints.size(); k++) {
            std::cout << VectorDump<double> (gotojoints[k].position);
        }
#endif
        return gotojoints;

    } else // if (RCS::Cnc.eCartesianMotionPlanner == RCS::CController::WAYPOINT) {
    {
#ifdef MOVEITKIN
        std::vector<double> oldjoints = RCS::Controller.status.currentjoints.position;
        for (size_t i = 0; i < poses.size(); i++) {

            //RCS::Cnc.Kinematics()->SetJointValues(oldjoints);
            std::vector<double> joints = RCS::Cnc.Kinematics()-> IK(poses[i], oldjoints);
#ifdef DEBUG
            std::cout << "GotoPose " << DumpPose(poses[i]).c_str();
            std::cout << "New Joints " << VectorDump<double>(joints).c_str();
#endif
            gotojoints.push_back(EmptyJointState(joints.size()));
            gotojoints.back().position = joints;
            oldjoints = joints;
        }
#endif
        return gotojoints;
    }
}

int SimpleMotionInterpreter::ParseCommand(RCS::CanonCmd cc) {
    //   IfDebug(Globals.ErrorMessage("SimpleMotionInterpreter::ParseCommand\n"));

    // This approach should debounce multiple commands to same position - e.g., 0->30, 0->30
    JointState currentjoints;
    RCS::Pose currentpose; // = RCS::Controller.status.currentpose;

    //RCS::CanonCmd lastrobotcmd = Cnc.GetLastRobotCommand();
    currentjoints = RCS::Cnc.GetLastJointState(); //  open loop - "not actual"
    currentpose = RCS::Cnc.Kinematics()->FK(currentjoints.position);
#ifdef HEAVYDEBUG
    std::cout << "Current Joints " << VectorDump<double>(currentjoints.position).c_str();
    std::cout << "Current Pose " << DumpPose(currentpose).c_str();
#endif
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // SET GRIPPERTS
    if (cc.crclcommand == CanonCmdType::CANON_SET_GRIPPER) {
        RCS::CanonCmd newcc = cc;
        //newcc.crclcommand = CanonCmdType::CANON_SET_GRIPPER;
        //newcc.eepercent=cc.eepercent;
        newcc.status = CanonStatusType::CANON_WAITING;
        Cnc.robotcmds.AddMsgQueue(newcc);
    }        ////////////////////////////////////////////////////////////////////////////////////////////////
        // MOVE JOINTS
    else if (cc.crclcommand == CanonCmdType::CANON_MOVE_JOINT) {
        rates = IRate(DEFAULT_JOINT_MAX_VEL, DEFAULT_JOINT_MAX_ACCEL, DEFAULT_LOOP_CYCLE);

        JointState joints;
        for (size_t i = 0; i < currentjoints.position.size(); i++) {
            joints.position.push_back(currentjoints.position[i]);
            joints.velocity.push_back(DEFAULT_JOINT_MAX_VEL);
            joints.effort.push_back(DEFAULT_JOINT_MAX_ACCEL);
        }

        std::vector<double> maxvel;
        std::vector<double> maxacc;
        // Check each joint, to see if joint is being actuated, if so, change goal position
        for (size_t i = 0; i < cc.jointnum.size(); i++) {
            size_t n = cc.jointnum[i];
            joints.position[n] = cc.joints.position[n]; // joint numbers already adjusted from CRCL to rcs model
            joints.velocity[n] = cc.joints.velocity[n];
            joints.effort[n] = cc.joints.effort[n];
            maxvel.push_back(cc.joints.velocity[n]);
            maxacc.push_back(cc.joints.effort[n]);
        }
        // not sure what happends if no elements in maxvel or maxacc... - should never happen
        double jointsmaxvel = *(std::min_element(std::begin(maxvel), std::end(maxvel)));
        double jointsmaxacc = *(std::min_element(std::begin(maxacc), std::end(maxacc)));
#ifdef HEAVYDEBUG
        std::cout << "Updated Joints Position " << VectorDump<double>(joints.position).c_str();
        std::cout << "Updated Joints Velocity " << VectorDump<double>(joints.velocity).c_str();
        std::cout << "Updated Joints Effort " << VectorDump<double>(joints.effort).c_str();
#endif
        std::vector<JointState > gotojoints;

        if (RCS::Cnc.eJointMotionPlanner == RCS::CController::WAYPOINT) {
            gotojoints = motioncontrol.computeCoorindatedWaypoints(currentjoints.position, joints.position, 0.001, true);
        } else if (RCS::Cnc.eJointMotionPlanner == RCS::CController::BASIC) {
            TrajectoryMaker maker;
            maker.Rates().CurrentFeedrate() = jointsmaxvel;
            maker.Rates().MaximumAccel() = jointsmaxacc;
            maker.setRates(rates);
            maker.makeJointPositionTrajectory(rates, currentjoints.position, joints.position);
            gotojoints = maker.GetJtsPlan();
        }
#ifdef MOVEITPLANNER
        else if (RCS::Cnc.eJointMotionPlanner == RCS::CController::MOVEIT) {
            if (!RCS::Cnc.MoveitPlanner()->Plan(joints))
                return -1;
            gotojoints = RCS::Cnc.MoveitPlanner()->GetJtsPlan();
        }
#endif
        else {
            gotojoints = motioncontrol.computeCoorindatedWaypoints(currentjoints.position, joints.position, 0.001, true);
        }
        if (cc.bCoordinated) {
            AddJointCommands(gotojoints);
        } else {
            // uncoordinated motion - 1st 0 joint, then 1 joint motion, etc.
            // unlikely to crash into itself with this joint motion
            for (size_t k = 0; k < currentjoints.position.size(); k++) {
                JointState eachjoint;
                eachjoint.position = currentjoints.position;
                eachjoint.position[k] = joints.position[k];
                TrajectoryMaker maker;
                maker.Rates().CurrentFeedrate() = jointsmaxvel;
                maker.Rates().MaximumAccel() = jointsmaxacc;
                maker.setRates(rates);
                maker.makeJointPositionTrajectory(rates, currentjoints.position, eachjoint.position);
                gotojoints = maker.GetJtsPlan();
                AddJointCommands(gotojoints);
            }
        }
    }////////////////////////////////////////////////////////////////////////////////////////////////
        // STOP MOTION
    else if (cc.crclcommand == CanonCmdType::CANON_STOP_MOTION) {
        std::vector<std::vector<double> > displacements(status.currentjoints.velocity.size(), std::vector<double>());
        cc.jointnum.clear();

        // clear motion queue   - we are stopping asap!
        robotcmds.ClearMsgQueue();
    }////////////////////////////////////////////////////////////////////////////////////////////////
        // MOVE CARTESIAN
    else if (cc.crclcommand == CanonCmdType::CANON_MOVE_TO) {

        rates = cc.Rates(); // IRate(DEFAULT_CART_MAX_VEL, DEFAULT_CART_MAX_ACCEL, DEFAULT_LOOP_CYCLE);
        RCS::Pose goalpose;
        tf::poseMsgToTF(cc.finalpose, goalpose);
#ifdef MOVEITKIN
        if (RCS::Cnc.Kinematics()->IsSingular(goalpose, 0.0001)) {
            std::cout << "Is singular pose: " << DumpPose(goalpose).c_str();
        }
#endif
        std::vector<JointState> gotojoints;
        std::cout << "Current Pose " << DumpPose(currentpose).c_str();
        std::vector<RCS::Pose> poses = motioncontrol.computeWaypoints(currentpose, goalpose,
                0.01, // cc.Rates().CurrentFeedrate() * DEFAULT_LOOP_CYCLE, //0.01, 
                true);
        for (size_t k = 0; k < poses.size(); k++)
            std::cout << "\n\nWaypoint[" << k << "]" << DumpPose(poses[k]).c_str();

        gotojoints = PlanCartesianMotion(poses);
        AddJointCommands(gotojoints);
    } else if (cc.crclcommand == CanonCmdType::CANON_MOVE_THRU) {
        rates = IRate(DEFAULT_CART_MAX_VEL, DEFAULT_CART_MAX_ACCEL, DEFAULT_LOOP_CYCLE);
        std::vector<JointState> gotojoints;
        // FIXME: waypoints must have a point!
        std::vector<RCS::Pose> poses(sizeof (cc.waypoints) / sizeof (cc.waypoints[0]));
        poses.insert(poses.begin(), currentpose); // add beginning pose -again?
        // and in case interrupted
        gotojoints = PlanCartesianMotion(poses);
        AddJointCommands(gotojoints);
    } else if (cc.crclcommand == CanonCmdType::CANON_DWELL) {
        // wait here or at robot command thread?
        // Could just copy over command to robot
        RCS::CanonCmd newcc;
        newcc.crclcommand = CanonCmdType::CANON_DWELL;
        newcc.status = CanonStatusType::CANON_WAITING;
        newcc.dwell_seconds = cc.dwell_seconds;
        Cnc.robotcmds.AddMsgQueue(newcc);
    }
    return 0;
}
#endif