<html><head>
<!-- CSS goes in the document HEAD or added to your external stylesheet -->
<style type="text/css">
table.altrowstable {
               font-family: verdana,arial,sans-serif;
               font-size:11px;
               color:#333333;
               border-width: 1px;
               border-color: #a9c6c9;
               border-collapse: collapse;
}
table.altrowstable th {
               border-width: 1px;
               padding: 0px;
               border-style: solid;
               border-color: #a9c6c9;
}
table.altrowstable td {
               border-width: 1px;
               padding: 0px;
               border-style: solid;
               border-color: #a9c6c9;
}
.oddrowcolor{
               background-color:#d4e3e5;
}
.evenrowcolor{
               background-color:#c3dde0;
}
@page {
    @bottom {
        content: "Page " counter(page) " of " counter(pages)
    }
}
</style>
</head>
<body>
<h1>actionlib_msgs</h1>
<h2><A NAME="actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>time</td><td>stamp</td><td>  The stamp should store the time at which this goal was requested.  It is used by an action server when it tries to preempt all  goals that were requested before a certain time</td></tr>
<tr><td>string</td><td>id</td><td>  The id provides a way to associate feedback and  result message with specific goal requests. The id  specified must be unique.</td></tr>
</table>
<h2><A NAME="actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td>uint8</td><td>status</td><td></td></tr>
<tr><td>uint8</td><td>PENDING</td><td></td></tr>
<tr><td>uint8</td><td>ACTIVE</td><td></td></tr>
<tr><td>uint8</td><td>PREEMPTED</td><td></td></tr>
<tr><td>uint8</td><td>SUCCEEDED</td><td>    and has since completed its execution (Terminal State)</td></tr>
<tr><td>uint8</td><td>ABORTED</td><td></td></tr>
<tr><td>uint8</td><td>REJECTED</td><td>     to some failure (Terminal State)</td></tr>
<tr><td>uint8</td><td>PREEMPTING</td><td>     because the goal was unattainable or invalid (Terminal State)</td></tr>
<tr><td>uint8</td><td>RECALLING</td><td>     and has not yet completed execution</td></tr>
<tr><td>uint8</td><td>RECALLED</td><td>     but the action server has not yet confirmed that the goal is canceled</td></tr>
<tr><td>uint8</td><td>LOST</td><td>     and was successfully cancelled (Terminal State)</td></tr>
<tr><td>string</td><td>text</td><td>     sent over the wire by an action server Allow for the user to associate a string with GoalStatus for debugging</td></tr>
</table>
<h2><A NAME="actionlib_msgs_GoalStatusArray">actionlib_msgs/GoalStatusArray</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Stores the statuses for goals that are currently being tracked  by an action server</td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">GoalStatus[]</A></td><td>status_list</td><td></td></tr>
</table>
<h1>control_msgs</h1>
<h2><A NAME="control_msgs_FollowJointTrajectoryAction">control_msgs/FollowJointTrajectoryAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#control_msgs_FollowJointTrajectoryActionGoal">FollowJointTrajectoryActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#control_msgs_FollowJointTrajectoryActionResult">FollowJointTrajectoryActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#control_msgs_FollowJointTrajectoryActionFeedback">FollowJointTrajectoryActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_FollowJointTrajectoryActionFeedback">control_msgs/FollowJointTrajectoryActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_FollowJointTrajectoryFeedback">FollowJointTrajectoryFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_FollowJointTrajectoryActionGoal">control_msgs/FollowJointTrajectoryActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#control_msgs_FollowJointTrajectoryGoal">FollowJointTrajectoryGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_FollowJointTrajectoryActionResult">control_msgs/FollowJointTrajectoryActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_FollowJointTrajectoryResult">FollowJointTrajectoryResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_FollowJointTrajectoryFeedback">control_msgs/FollowJointTrajectoryFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string[]</td><td>joint_names</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></td><td>desired</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></td><td>actual</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></td><td>error</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_FollowJointTrajectoryGoal">control_msgs/FollowJointTrajectoryGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  The joint trajectory to follow</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>trajectory</td><td></td></tr>
<tr><td><A HREF="#control_msgs_JointTolerance">JointTolerance[]</A></td><td>path_tolerance</td><td>  Tolerances for the trajectory.  If the measured joint values fall  outside the tolerances the trajectory goal is aborted.  Any  tolerances that are not specified (by being omitted or set to 0) are  set to the defaults for the action server (often taken from the  parameter server).  Tolerances applied to the joints as the trajectory is executed.  If  violated, the goal aborts with error_code set to  PATH_TOLERANCE_VIOLATED.</td></tr>
<tr><td><A HREF="#control_msgs_JointTolerance">JointTolerance[]</A></td><td>goal_tolerance</td><td>  To report success, the joints must be within goal_tolerance of the  final trajectory value.  The goal must be achieved by time the  trajectory ends plus goal_time_tolerance.  (goal_time_tolerance  allows some leeway in time, so that the trajectory goal can still  succeed even if the joints reach the goal some time after the  precise end time of the trajectory).   If the joints are not within goal_tolerance after "trajectory finish  time" + goal_time_tolerance, the goal aborts with error_code set to  GOAL_TOLERANCE_VIOLATED</td></tr>
<tr><td>duration</td><td>goal_time_tolerance</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_FollowJointTrajectoryResult">control_msgs/FollowJointTrajectoryResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>error_code</td><td></td></tr>
<tr><td>int32</td><td>SUCCESSFUL</td><td></td></tr>
<tr><td>int32</td><td>INVALID_GOAL</td><td></td></tr>
<tr><td>int32</td><td>INVALID_JOINTS</td><td></td></tr>
<tr><td>int32</td><td>OLD_HEADER_TIMESTAMP</td><td></td></tr>
<tr><td>int32</td><td>PATH_TOLERANCE_VIOLATED</td><td></td></tr>
<tr><td>int32</td><td>GOAL_TOLERANCE_VIOLATED</td><td></td></tr>
<tr><td>string</td><td>error_string</td><td>  Human readable description of the error code. Contains complementary  information that is especially useful when execution fails, for instance:  - INVALID_GOAL: The reason for the invalid goal (e.g., the requested    trajectory is in the past).  - INVALID_JOINTS: The mismatch between the expected controller joints    and those provided in the goal.  - PATH_TOLERANCE_VIOLATED and GOAL_TOLERANCE_VIOLATED: Which joint    violated which tolerance, and by how much.</td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommand">control_msgs/GripperCommand</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>position</td><td></td></tr>
<tr><td>float64</td><td>max_effort</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandAction">control_msgs/GripperCommandAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#control_msgs_GripperCommandActionGoal">GripperCommandActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#control_msgs_GripperCommandActionResult">GripperCommandActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#control_msgs_GripperCommandActionFeedback">GripperCommandActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandActionFeedback">control_msgs/GripperCommandActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_GripperCommandFeedback">GripperCommandFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandActionGoal">control_msgs/GripperCommandActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#control_msgs_GripperCommandGoal">GripperCommandGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandActionResult">control_msgs/GripperCommandActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_GripperCommandResult">GripperCommandResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandFeedback">control_msgs/GripperCommandFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>position</td><td></td></tr>
<tr><td>float64</td><td>effort</td><td></td></tr>
<tr><td>bool</td><td>stalled</td><td></td></tr>
<tr><td>bool</td><td>reached_goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandGoal">control_msgs/GripperCommandGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#control_msgs_GripperCommand">GripperCommand</A></td><td>command</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_GripperCommandResult">control_msgs/GripperCommandResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>position</td><td></td></tr>
<tr><td>float64</td><td>effort</td><td></td></tr>
<tr><td>bool</td><td>stalled</td><td></td></tr>
<tr><td>bool</td><td>reached_goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointControllerState">control_msgs/JointControllerState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float64</td><td>set_point</td><td></td></tr>
<tr><td>float64</td><td>process_value</td><td></td></tr>
<tr><td>float64</td><td>process_value_dot</td><td></td></tr>
<tr><td>float64</td><td>error</td><td></td></tr>
<tr><td>float64</td><td>time_step</td><td></td></tr>
<tr><td>float64</td><td>command</td><td></td></tr>
<tr><td>float64</td><td>p</td><td></td></tr>
<tr><td>float64</td><td>i</td><td></td></tr>
<tr><td>float64</td><td>d</td><td></td></tr>
<tr><td>float64</td><td>i_clamp</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTolerance">control_msgs/JointTolerance</A></h2>
<table class="altrowstable"">
<p>  The tolerances specify the amount the position, velocity, and  accelerations can vary from the setpoints.  For example, in the case  of trajectory control, when the actual position varies beyond  (desired position + position tolerance), the trajectory goal may  abort.    There are two special values for tolerances:   * 0 - The tolerance is unspecified and will remain at whatever the default is   * -1 - The tolerance is "erased".  If there was a default, the joint will be          allowed to move without restriction.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td></td></tr>
<tr><td>float64</td><td>position</td><td></td></tr>
<tr><td>float64</td><td>velocity</td><td></td></tr>
<tr><td>float64</td><td>acceleration</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryAction">control_msgs/JointTrajectoryAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#control_msgs_JointTrajectoryActionGoal">JointTrajectoryActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#control_msgs_JointTrajectoryActionResult">JointTrajectoryActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#control_msgs_JointTrajectoryActionFeedback">JointTrajectoryActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryActionFeedback">control_msgs/JointTrajectoryActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_JointTrajectoryFeedback">JointTrajectoryFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryActionGoal">control_msgs/JointTrajectoryActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#control_msgs_JointTrajectoryGoal">JointTrajectoryGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryActionResult">control_msgs/JointTrajectoryActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_JointTrajectoryResult">JointTrajectoryResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryControllerState">control_msgs/JointTrajectoryControllerState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string[]</td><td>joint_names</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></td><td>desired</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></td><td>actual</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></td><td>error</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryFeedback">control_msgs/JointTrajectoryFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p></table>
<h2><A NAME="control_msgs_JointTrajectoryGoal">control_msgs/JointTrajectoryGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>trajectory</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_JointTrajectoryResult">control_msgs/JointTrajectoryResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p></table>
<h2><A NAME="control_msgs_PointHeadAction">control_msgs/PointHeadAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#control_msgs_PointHeadActionGoal">PointHeadActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#control_msgs_PointHeadActionResult">PointHeadActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#control_msgs_PointHeadActionFeedback">PointHeadActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_PointHeadActionFeedback">control_msgs/PointHeadActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_PointHeadFeedback">PointHeadFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_PointHeadActionGoal">control_msgs/PointHeadActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#control_msgs_PointHeadGoal">PointHeadGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_PointHeadActionResult">control_msgs/PointHeadActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_PointHeadResult">PointHeadResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_PointHeadFeedback">control_msgs/PointHeadFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>pointing_angle_error</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_PointHeadGoal">control_msgs/PointHeadGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_PointStamped">geometry_msgs/PointStamped</A></td><td>target</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>pointing_axis</td><td></td></tr>
<tr><td>string</td><td>pointing_frame</td><td></td></tr>
<tr><td>duration</td><td>min_duration</td><td></td></tr>
<tr><td>float64</td><td>max_velocity</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_PointHeadResult">control_msgs/PointHeadResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p></table>
<h2><A NAME="control_msgs_SingleJointPositionAction">control_msgs/SingleJointPositionAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#control_msgs_SingleJointPositionActionGoal">SingleJointPositionActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#control_msgs_SingleJointPositionActionResult">SingleJointPositionActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#control_msgs_SingleJointPositionActionFeedback">SingleJointPositionActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_SingleJointPositionActionFeedback">control_msgs/SingleJointPositionActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_SingleJointPositionFeedback">SingleJointPositionFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_SingleJointPositionActionGoal">control_msgs/SingleJointPositionActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#control_msgs_SingleJointPositionGoal">SingleJointPositionGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_SingleJointPositionActionResult">control_msgs/SingleJointPositionActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#control_msgs_SingleJointPositionResult">SingleJointPositionResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_SingleJointPositionFeedback">control_msgs/SingleJointPositionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float64</td><td>position</td><td></td></tr>
<tr><td>float64</td><td>velocity</td><td></td></tr>
<tr><td>float64</td><td>error</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_SingleJointPositionGoal">control_msgs/SingleJointPositionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>position</td><td></td></tr>
<tr><td>duration</td><td>min_duration</td><td></td></tr>
<tr><td>float64</td><td>max_velocity</td><td></td></tr>
</table>
<h2><A NAME="control_msgs_SingleJointPositionResult">control_msgs/SingleJointPositionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p></table>
<h1>controller_manager_msgs</h1>
<h2><A NAME="controller_manager_msgs_ControllerState">controller_manager_msgs/ControllerState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td></td></tr>
<tr><td>string</td><td>state</td><td></td></tr>
<tr><td>string</td><td>type</td><td></td></tr>
<tr><td>string</td><td>hardware_interface</td><td></td></tr>
<tr><td>string[]</td><td>resources</td><td></td></tr>
</table>
<h2><A NAME="controller_manager_msgs_ControllerStatistics">controller_manager_msgs/ControllerStatistics</A></h2>
<table class="altrowstable"">
<p>  This message contains the state of one realtime controller  that was spawned in the controller manager</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td>  the name of the controller</td></tr>
<tr><td>string</td><td>type</td><td>  the type of the controller</td></tr>
<tr><td>time</td><td>timestamp</td><td>  the time at which these controller statistics were measured</td></tr>
<tr><td>bool</td><td>running</td><td>  bool that indicates if the controller is currently  in a running or a stopped state</td></tr>
<tr><td>duration</td><td>max_time</td><td>  the maximum time the update loop of the controller ever needed to complete</td></tr>
<tr><td>duration</td><td>mean_time</td><td>  the average time the update loop of the controller needs to complete.  the average is computed in a sliding time window.</td></tr>
<tr><td>duration</td><td>variance_time</td><td>  the variance on the time the update loop of the controller needs to complete.  the variance applies to a sliding time window.</td></tr>
<tr><td>int32</td><td>num_control_loop_overruns</td><td>  the number of times this controller broke the realtime loop</td></tr>
<tr><td>time</td><td>time_last_control_loop_overrun</td><td>  the timestamp of the last time this controller broke the realtime loop</td></tr>
</table>
<h2><A NAME="controller_manager_msgs_ControllersStatistics">controller_manager_msgs/ControllersStatistics</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_Header">std_msgs/Header</A></td><td>header</td><td></td></tr>
<tr><td><A HREF="#controller_manager_msgs_ControllerStatistics">controller_manager_msgs/ControllerStatistics[]</A></td><td>controller</td><td></td></tr>
</table>
<h1>diagnostic_msgs</h1>
<h2><A NAME="diagnostic_msgs_DiagnosticArray">diagnostic_msgs/DiagnosticArray</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This message is used to send diagnostic information about the state of the robot</td></tr>
<tr><td><A HREF="#diagnostic_msgs_DiagnosticStatus">DiagnosticStatus[]</A></td><td>status</td><td></td></tr>
</table>
<h2><A NAME="diagnostic_msgs_DiagnosticStatus">diagnostic_msgs/DiagnosticStatus</A></h2>
<table class="altrowstable"">
<p>  This message holds the status of an individual component of the robot.  </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>byte</td><td>OK=0</td><td>  Possible levels of operations</td></tr>
<tr><td>byte</td><td>WARN=1</td><td></td></tr>
<tr><td>byte</td><td>ERROR=2</td><td></td></tr>
<tr><td>byte</td><td>STALE=3</td><td></td></tr>
<tr><td>byte</td><td>level</td><td></td></tr>
<tr><td>string</td><td>name</td><td></td></tr>
<tr><td>string</td><td>message</td><td></td></tr>
<tr><td>string</td><td>hardware_id</td><td></td></tr>
<tr><td><A HREF="#diagnostic_msgs_KeyValue">KeyValue[]</A></td><td>values</td><td></td></tr>
</table>
<h2><A NAME="diagnostic_msgs_KeyValue">diagnostic_msgs/KeyValue</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>key</td><td></td></tr>
<tr><td>string</td><td>value</td><td></td></tr>
</table>
<h1>gazebo_msgs</h1>
<h2><A NAME="gazebo_msgs_ContactState">gazebo_msgs/ContactState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>info</td><td></td></tr>
<tr><td>string</td><td>collision1_name</td><td></td></tr>
<tr><td>string</td><td>collision2_name</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Wrench">geometry_msgs/Wrench[]</A></td><td>wrenches</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Wrench">geometry_msgs/Wrench</A></td><td>total_wrench</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3[]</A></td><td>contact_positions</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3[]</A></td><td>contact_normals</td><td></td></tr>
<tr><td>float64[]</td><td>depths</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_ContactsState">gazebo_msgs/ContactsState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#gazebo_msgs_ContactState">gazebo_msgs/ContactState[]</A></td><td>states</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_LinkState">gazebo_msgs/LinkState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>link_name</td><td>  @todo: FIXME: sets pose and twist of a link.  All children link poses/twists of the URDF tree are not updated accordingly, but should be.</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist</A></td><td>twist</td><td></td></tr>
<tr><td>string</td><td>reference_frame</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_LinkStates">gazebo_msgs/LinkStates</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string[]</td><td>name</td><td>  broadcast all link states in world frame</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist[]</A></td><td>twist</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_ModelState">gazebo_msgs/ModelState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>model_name</td><td>  Set Gazebo Model pose and twist</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist</A></td><td>twist</td><td></td></tr>
<tr><td>string</td><td>reference_frame</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_ModelStates">gazebo_msgs/ModelStates</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string[]</td><td>name</td><td>  broadcast all model states in world frame</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist[]</A></td><td>twist</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_ODEJointProperties">gazebo_msgs/ODEJointProperties</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64[]</td><td>damping</td><td>  access to low level joint properties, change these at your own risk</td></tr>
<tr><td>float64[]</td><td>hiStop</td><td></td></tr>
<tr><td>float64[]</td><td>loStop</td><td></td></tr>
<tr><td>float64[]</td><td>erp</td><td></td></tr>
<tr><td>float64[]</td><td>cfm</td><td></td></tr>
<tr><td>float64[]</td><td>stop_erp</td><td></td></tr>
<tr><td>float64[]</td><td>stop_cfm</td><td></td></tr>
<tr><td>float64[]</td><td>fudge_factor</td><td></td></tr>
<tr><td>float64[]</td><td>fmax</td><td></td></tr>
<tr><td>float64[]</td><td>vel</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_ODEPhysics">gazebo_msgs/ODEPhysics</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>bool</td><td>auto_disable_bodies</td><td></td></tr>
<tr><td>uint32</td><td>sor_pgs_precon_iters</td><td></td></tr>
<tr><td>uint32</td><td>sor_pgs_iters</td><td></td></tr>
<tr><td>float64</td><td>sor_pgs_w</td><td></td></tr>
<tr><td>float64</td><td>sor_pgs_rms_error_tol</td><td></td></tr>
<tr><td>float64</td><td>contact_surface_layer</td><td></td></tr>
<tr><td>float64</td><td>contact_max_correcting_vel</td><td></td></tr>
<tr><td>float64</td><td>cfm</td><td></td></tr>
<tr><td>float64</td><td>erp</td><td></td></tr>
<tr><td>uint32</td><td>max_contacts</td><td></td></tr>
</table>
<h2><A NAME="gazebo_msgs_WorldState">gazebo_msgs/WorldState</A></h2>
<table class="altrowstable"">
<p>  This is a message that holds data necessary to reconstruct a snapshot of the world   = Approach to Message Passing =  The state of the world is defined by either    1. Inertial Model pose, twist       * kinematic data - connectivity graph from Model to each Link       * joint angles       * joint velocities       * Applied forces - Body wrench         * relative transform from Body to each collision Geom  Or    2. Inertial (absolute) Body pose, twist, wrench       * relative transform from Body to each collision Geom - constant, so not sent over wire       * back compute from canonical body info to get Model pose and twist.   Chooing (2.) because it matches most physics engines out there    and is simpler.   = Future =  Consider impacts on using reduced coordinates / graph (parent/child links) approach    constraint and physics solvers.   = Application =  This message is used to do the following:    * reconstruct the world and objects for sensor generation    * stop / start simulation - need pose, twist, wrench of each body    * collision detection - need pose of each collision geometry.  velocity/acceleration if    = Assumptions =  Assuming that each (physics) processor node locally already has    * collision information - Trimesh for Geoms, etc    * relative transforms from Body to Geom - this is assumed to be fixed, do not send oved wire    * inertial information - does not vary in time    * visual information - does not vary in time </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string[]</td><td>name</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist[]</A></td><td>twist</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Wrench">geometry_msgs/Wrench[]</A></td><td>wrench</td><td></td></tr>
</table>
<h1>geometry_msgs</h1>
<h2><A NAME="geometry_msgs_Accel">geometry_msgs/Accel</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>linear</td><td>  This expresses acceleration in free space broken into its linear and angular parts.</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>angular</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_AccelStamped">geometry_msgs/AccelStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  An accel with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Accel">Accel</A></td><td>accel</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_AccelWithCovariance">geometry_msgs/AccelWithCovariance</A></h2>
<table class="altrowstable"">
<p>  This expresses acceleration in free space with uncertainty.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Accel">Accel</A></td><td>accel</td><td></td></tr>
<tr><td>float64[36]</td><td>covariance</td><td>  Row-major representation of the 6x6 covariance matrix  The orientation parameters use a fixed-axis representation.  In order, the parameters are:  (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)</td></tr>
</table>
<h2><A NAME="geometry_msgs_AccelWithCovarianceStamped">geometry_msgs/AccelWithCovarianceStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This represents an estimated accel with reference coordinate frame and timestamp.</td></tr>
<tr><td><A HREF="#geometry_msgs_AccelWithCovariance">AccelWithCovariance</A></td><td>accel</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Inertia">geometry_msgs/Inertia</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>m</td><td>  Mass [kg]</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>com</td><td>  Center of mass [m]</td></tr>
<tr><td>float64</td><td>ixx</td><td>  Inertia Tensor [kg-m^2]      | ixx ixy ixz |  I = | ixy iyy iyz |      | ixz iyz izz |</td></tr>
<tr><td>float64</td><td>ixy</td><td></td></tr>
<tr><td>float64</td><td>ixz</td><td></td></tr>
<tr><td>float64</td><td>iyy</td><td></td></tr>
<tr><td>float64</td><td>iyz</td><td></td></tr>
<tr><td>float64</td><td>izz</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_InertiaStamped">geometry_msgs/InertiaStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Inertia">Inertia</A></td><td>inertia</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Point">geometry_msgs/Point</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>x</td><td>  This contains the position of a point in free space</td></tr>
<tr><td>float64</td><td>y</td><td></td></tr>
<tr><td>float64</td><td>z</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Point32">geometry_msgs/Point32</A></h2>
<table class="altrowstable"">
<p>  This contains the position of a point in free space(with 32 bits of precision).  It is recommeded to use Point wherever possible instead of Point32.      This recommendation is to promote interoperability.     This message is designed to take up less space when sending  lots of points at once, as in the case of a PointCloud.  </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float32</td><td>x</td><td></td></tr>
<tr><td>float32</td><td>y</td><td></td></tr>
<tr><td>float32</td><td>z</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_PointStamped">geometry_msgs/PointStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This represents a Point with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Point">Point</A></td><td>point</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Polygon">geometry_msgs/Polygon</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Point32">Point32[]</A></td><td>points</td><td> A specification of a polygon where the first and last points are assumed to be connected</td></tr>
</table>
<h2><A NAME="geometry_msgs_PolygonStamped">geometry_msgs/PolygonStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This represents a Polygon with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Polygon">Polygon</A></td><td>polygon</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Pose">geometry_msgs/Pose</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Point">Point</A></td><td>position</td><td>  A representation of pose in free space, composed of postion and orientation. </td></tr>
<tr><td><A HREF="#geometry_msgs_Quaternion">Quaternion</A></td><td>orientation</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Pose2D">geometry_msgs/Pose2D</A></h2>
<table class="altrowstable"">
<p>  This expresses a position and orientation on a 2D manifold.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>x</td><td></td></tr>
<tr><td>float64</td><td>y</td><td></td></tr>
<tr><td>float64</td><td>theta</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_PoseArray">geometry_msgs/PoseArray</A></h2>
<table class="altrowstable"">
<p>  An array of poses with a header for global reference.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">Pose[]</A></td><td>poses</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  A Pose with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">Pose</A></td><td>pose</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_PoseWithCovariance">geometry_msgs/PoseWithCovariance</A></h2>
<table class="altrowstable"">
<p>  This represents a pose in free space with uncertainty.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Pose">Pose</A></td><td>pose</td><td></td></tr>
<tr><td>float64[36]</td><td>covariance</td><td>  Row-major representation of the 6x6 covariance matrix  The orientation parameters use a fixed-axis representation.  In order, the parameters are:  (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)</td></tr>
</table>
<h2><A NAME="geometry_msgs_PoseWithCovarianceStamped">geometry_msgs/PoseWithCovarianceStamped</A></h2>
<table class="altrowstable"">
<p>  This expresses an estimated pose with a reference coordinate frame and timestamp</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_PoseWithCovariance">PoseWithCovariance</A></td><td>pose</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Quaternion">geometry_msgs/Quaternion</A></h2>
<table class="altrowstable"">
<p>  This represents an orientation in free space in quaternion form.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>x</td><td></td></tr>
<tr><td>float64</td><td>y</td><td></td></tr>
<tr><td>float64</td><td>z</td><td></td></tr>
<tr><td>float64</td><td>w</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_QuaternionStamped">geometry_msgs/QuaternionStamped</A></h2>
<table class="altrowstable"">
<p>  This represents an orientation with reference coordinate frame and timestamp.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Quaternion">Quaternion</A></td><td>quaternion</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Transform">geometry_msgs/Transform</A></h2>
<table class="altrowstable"">
<p>  This represents the transform between two coordinate frames in free space.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>translation</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Quaternion">Quaternion</A></td><td>rotation</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_TransformStamped">geometry_msgs/TransformStamped</A></h2>
<table class="altrowstable"">
<p>  This expresses a transform from coordinate frame header.frame_id  to the coordinate frame child_frame_id   This message is mostly used by the   <a href="http://www.ros.org/wiki/tf">tf</a> package.   See its documentation for more information.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string</td><td>child_frame_id</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Transform">Transform</A></td><td>transform</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Twist">geometry_msgs/Twist</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>linear</td><td>  This expresses velocity in free space broken into its linear and angular parts.</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>angular</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_TwistStamped">geometry_msgs/TwistStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  A twist with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">Twist</A></td><td>twist</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_TwistWithCovariance">geometry_msgs/TwistWithCovariance</A></h2>
<table class="altrowstable"">
<p>  This expresses velocity in free space with uncertainty.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Twist">Twist</A></td><td>twist</td><td></td></tr>
<tr><td>float64[36]</td><td>covariance</td><td>  Row-major representation of the 6x6 covariance matrix  The orientation parameters use a fixed-axis representation.  In order, the parameters are:  (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)</td></tr>
</table>
<h2><A NAME="geometry_msgs_TwistWithCovarianceStamped">geometry_msgs/TwistWithCovarianceStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This represents an estimated twist with reference coordinate frame and timestamp.</td></tr>
<tr><td><A HREF="#geometry_msgs_TwistWithCovariance">TwistWithCovariance</A></td><td>twist</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Vector3">geometry_msgs/Vector3</A></h2>
<table class="altrowstable"">
<p>  This represents a vector in free space. </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>x</td><td></td></tr>
<tr><td>float64</td><td>y</td><td></td></tr>
<tr><td>float64</td><td>z</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Vector3Stamped">geometry_msgs/Vector3Stamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This represents a Vector3 with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>vector</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_Wrench">geometry_msgs/Wrench</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>force</td><td>  This represents force in free space, separated into  its linear and angular parts.</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">Vector3</A></td><td>torque</td><td></td></tr>
</table>
<h2><A NAME="geometry_msgs_WrenchStamped">geometry_msgs/WrenchStamped</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  A wrench with reference coordinate frame and timestamp</td></tr>
<tr><td><A HREF="#geometry_msgs_Wrench">Wrench</A></td><td>wrench</td><td></td></tr>
</table>
<h1>household_objects_database_msgs</h1>
<h2><A NAME="household_objects_database_msgs_DatabaseModelPose">household_objects_database_msgs/DatabaseModelPose</A></h2>
<table class="altrowstable"">
<p>  Informs that a specific model from the Model Database has been   identified at a certain location</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>model_id</td><td>  the database id of the model</td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectType">object_recognition_msgs/ObjectType</A></td><td>type</td><td>  if the object was recognized by the ORK pipeline, its type will be in here  if this is not empty, then the string in here will be converted to a household_objects_database id  leave this empty if providing an id in the model_id field</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>pose</td><td>  the pose that it can be found in</td></tr>
<tr><td>float32</td><td>confidence</td><td>  a measure of the confidence level in this detection result</td></tr>
<tr><td>string</td><td>detector_name</td><td>  the name of the object detector that generated this detection result</td></tr>
</table>
<h2><A NAME="household_objects_database_msgs_DatabaseModelPoseList">household_objects_database_msgs/DatabaseModelPoseList</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#household_objects_database_msgs_DatabaseModelPose">DatabaseModelPose[]</A></td><td>model_list</td><td>  stores a list of possible database models recognition results</td></tr>
</table>
<h2><A NAME="household_objects_database_msgs_DatabaseReturnCode">household_objects_database_msgs/DatabaseReturnCode</A></h2>
<table class="altrowstable"">
<p>  return codes for database-related services</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>UNKNOWN_ERROR</td><td></td></tr>
<tr><td>int32</td><td>DATABASE_NOT_CONNECTED</td><td></td></tr>
<tr><td>int32</td><td>DATABASE_QUERY_ERROR</td><td></td></tr>
<tr><td>int32</td><td>SUCCESS</td><td></td></tr>
<tr><td>int32</td><td>code</td><td></td></tr>
</table>
<h2><A NAME="household_objects_database_msgs_DatabaseScan">household_objects_database_msgs/DatabaseScan</A></h2>
<table class="altrowstable"">
<p>  Contains the location of a stored point cloud scan of an object,   as well as additional metadata about that scan </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>model_id</td><td>  the database id of the model</td></tr>
<tr><td>string</td><td>bagfile_location</td><td>  the location of the bag file storing the scan</td></tr>
<tr><td>string</td><td>scan_source</td><td>  the source of the scan (e.g. simulation)</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>pose</td><td>  the ground truth pose of the object that was scanned</td></tr>
<tr><td>string</td><td>cloud_topic</td><td>  the topic that the points in the bag are published on</td></tr>
</table>
<h1>industrial_msgs</h1>
<h2><A NAME="industrial_msgs_DebugLevel">industrial_msgs/DebugLevel</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>val</td><td>  Debug level message enumeration.  This may replicate some functionality that  alreay exists in the ROS logger.  TODO: Get more information on the ROS Logger.</td></tr>
<tr><td>uint8</td><td>DEBUG</td><td></td></tr>
<tr><td>uint8</td><td>INFO</td><td></td></tr>
<tr><td>uint8</td><td>WARN</td><td></td></tr>
<tr><td>uint8</td><td>ERROR</td><td></td></tr>
<tr><td>uint8</td><td>FATAL</td><td></td></tr>
<tr><td>uint8</td><td>NONE</td><td></td></tr>
</table>
<h2><A NAME="industrial_msgs_DeviceInfo">industrial_msgs/DeviceInfo</A></h2>
<table class="altrowstable"">
<p>  Device info captures device agnostic information about a piece of hardware.  This message is meant as a generic as possible.  Items that don't apply should  be left blank.  This message is not meant to replace diagnostic messages, but  rather provide a standard service message that can be used to populate standard  components (like a GUI for example)</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>model</td><td></td></tr>
<tr><td>string</td><td>serial_number</td><td></td></tr>
<tr><td>string</td><td>hw_version</td><td></td></tr>
<tr><td>string</td><td>sw_version</td><td></td></tr>
<tr><td>string</td><td>address</td><td></td></tr>
</table>
<h2><A NAME="industrial_msgs_RobotMode">industrial_msgs/RobotMode</A></h2>
<table class="altrowstable"">
<p>  The Robot mode message encapsulates the mode/teach state of the robot  Typically this is controlled by the pendant key switch, but not always</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int8</td><td>val</td><td></td></tr>
<tr><td>int8</td><td>UNKNOWN=-1</td><td>  enumerated values</td></tr>
<tr><td>int8</td><td>MANUAL=1</td><td></td></tr>
<tr><td>int8</td><td>AUTO=2</td><td></td></tr>
</table>
<h2><A NAME="industrial_msgs_RobotStatus">industrial_msgs/RobotStatus</A></h2>
<table class="altrowstable"">
<p>  The RobotStatus message contains low level status information   that is specific to an industrial robot controller</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  The header frame ID is not used</td></tr>
<tr><td><A HREF="#industrial_msgs_RobotMode">industrial_msgs/RobotMode</A></td><td>mode</td><td>  The robot mode captures the operating mode of the robot.  When in  manual, remote motion is not possible.</td></tr>
<tr><td><A HREF="#industrial_msgs_TriState">industrial_msgs/TriState</A></td><td>e_stopped</td><td>  Estop status: True if robot is e-stopped.  The drives are disabled  and motion is not possible.  The e-stop condition must be acknowledged  and cleared before any motion can begin.</td></tr>
<tr><td><A HREF="#industrial_msgs_TriState">industrial_msgs/TriState</A></td><td>drives_powered</td><td>  Drive power status: True if drives are powered.  Motion commands will  automatically enable the drives if required.  Drive power is not requred  for possible motion</td></tr>
<tr><td><A HREF="#industrial_msgs_TriState">industrial_msgs/TriState</A></td><td>motion_possible</td><td>  Motion enabled: Ture if robot motion is possible.</td></tr>
<tr><td><A HREF="#industrial_msgs_TriState">industrial_msgs/TriState</A></td><td>in_motion</td><td>  Motion status: True if robot is in motion, otherwise false</td></tr>
<tr><td><A HREF="#industrial_msgs_TriState">industrial_msgs/TriState</A></td><td>in_error</td><td>  Error status: True if there is an error condition on the robot. Motion may  or may not be affected (see motion_possible)</td></tr>
<tr><td>int32</td><td>error_code</td><td>  Error code: Vendor specific error code (non zero indicates error)</td></tr>
</table>
<h2><A NAME="industrial_msgs_ServiceReturnCode">industrial_msgs/ServiceReturnCode</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int8</td><td>val</td><td>  Service return codes for simple requests.  All ROS-Industrial service  replies are required to have a return code indicating success or failure  Specific return codes for different failure should be negative.</td></tr>
<tr><td>int8</td><td>SUCCESS</td><td></td></tr>
<tr><td>int8</td><td>FAILURE</td><td></td></tr>
</table>
<h2><A NAME="industrial_msgs_TriState">industrial_msgs/TriState</A></h2>
<table class="altrowstable"">
<p>  The tri-state captures boolean values with the additional state of unknown</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int8</td><td>val</td><td></td></tr>
<tr><td>int8</td><td>UNKNOWN=-1</td><td>  enumerated values  Unknown or unavailable</td></tr>
<tr><td>int8</td><td>TRUE=1</td><td>  High state</td></tr>
<tr><td>int8</td><td>ON=1</td><td></td></tr>
<tr><td>int8</td><td>ENABLED=1</td><td></td></tr>
<tr><td>int8</td><td>HIGH=1</td><td></td></tr>
<tr><td>int8</td><td>CLOSED=1</td><td></td></tr>
<tr><td>int8</td><td>FALSE=0</td><td>  Low state</td></tr>
<tr><td>int8</td><td>OFF=0</td><td></td></tr>
<tr><td>int8</td><td>DISABLED=0</td><td></td></tr>
<tr><td>int8</td><td>LOW=0</td><td></td></tr>
<tr><td>int8</td><td>OPEN=0</td><td></td></tr>
</table>
<h1>manipulation_msgs</h1>
<h2><A NAME="manipulation_msgs_CartesianGains">manipulation_msgs/CartesianGains</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float64[]</td><td>gains</td><td></td></tr>
<tr><td>float64[]</td><td>fixed_frame</td><td></td></tr>
</table>
<h2><A NAME="manipulation_msgs_ClusterBoundingBox">manipulation_msgs/ClusterBoundingBox</A></h2>
<table class="altrowstable"">
<p>  contains a bounding box, which is essentially a box somewhere in space  used here ususally for the outlier-invariant bounding box of a cluster of points</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>pose_stamped</td><td> the pose of the box frame</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>dimensions</td><td> the dimensions of the box</td></tr>
</table>
<h2><A NAME="manipulation_msgs_Grasp">manipulation_msgs/Grasp</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>id</td><td>  A name for this grasp</td></tr>
<tr><td><A HREF="#sensor_msgs_JointState">sensor_msgs/JointState</A></td><td>pre_grasp_posture</td><td>  The internal posture of the hand for the pre-grasp  only positions are used</td></tr>
<tr><td><A HREF="#sensor_msgs_JointState">sensor_msgs/JointState</A></td><td>grasp_posture</td><td>  The internal posture of the hand for the grasp  positions and efforts are used</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>grasp_pose</td><td>  The position of the end-effector for the grasp</td></tr>
<tr><td>float64</td><td>grasp_quality</td><td>  The estimated probability of success for this grasp, or some other  measure of how "good" it is.</td></tr>
<tr><td><A HREF="#manipulation_msgs_GripperTranslation">GripperTranslation</A></td><td>approach</td><td>  The approach motion</td></tr>
<tr><td><A HREF="#manipulation_msgs_GripperTranslation">GripperTranslation</A></td><td>retreat</td><td>  The retreat motion</td></tr>
<tr><td>float32</td><td>max_contact_force</td><td>  the maximum contact force to use while grasping (<=0 to disable)</td></tr>
<tr><td>string[]</td><td>allowed_touch_objects</td><td>  an optional list of obstacles that we have semantic information about  and that can be touched/pushed/moved in the course of grasping</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningAction">manipulation_msgs/GraspPlanningAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningActionGoal">GraspPlanningActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningActionResult">GraspPlanningActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningActionFeedback">GraspPlanningActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningActionFeedback">manipulation_msgs/GraspPlanningActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningFeedback">GraspPlanningFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningActionGoal">manipulation_msgs/GraspPlanningActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningGoal">GraspPlanningGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningActionResult">manipulation_msgs/GraspPlanningActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningResult">GraspPlanningResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningErrorCode">manipulation_msgs/GraspPlanningErrorCode</A></h2>
<table class="altrowstable"">
<p>  Error codes for grasp and place planning</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>SUCCESS</td><td>  plan completed as expected</td></tr>
<tr><td>int32</td><td>TF_ERROR</td><td>  tf error encountered while transforming</td></tr>
<tr><td>int32</td><td>OTHER_ERROR</td><td>  some other error</td></tr>
<tr><td>int32</td><td>value</td><td>  the actual value of this error code</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningFeedback">manipulation_msgs/GraspPlanningFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#manipulation_msgs_Grasp">Grasp[]</A></td><td>grasps</td><td>  grasps planned so far</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningGoal">manipulation_msgs/GraspPlanningGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  Requests that grasp planning be performed on the object to be grasped  returns a list of grasps to be tested and executed</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>arm_name</td><td>  the arm being used</td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspableObject">GraspableObject</A></td><td>target</td><td>  the object to be grasped</td></tr>
<tr><td>string</td><td>collision_object_name</td><td>  the name that the target object has in the collision environment  can be left empty if no name is available</td></tr>
<tr><td>string</td><td>collision_support_surface_name</td><td>  the name that the support surface (e.g. table) has in the collision map  can be left empty if no name is available</td></tr>
<tr><td><A HREF="#manipulation_msgs_Grasp">Grasp[]</A></td><td>grasps_to_evaluate</td><td>  an optional list of grasps to be evaluated by the planner</td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspableObject">GraspableObject[]</A></td><td>movable_obstacles</td><td>  an optional list of obstacles that we have semantic information about  and that can be moved in the course of grasping</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspPlanningResult">manipulation_msgs/GraspPlanningResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#manipulation_msgs_Grasp">Grasp[]</A></td><td>grasps</td><td>  the list of planned grasps</td></tr>
<tr><td><A HREF="#manipulation_msgs_GraspPlanningErrorCode">GraspPlanningErrorCode</A></td><td>error_code</td><td>  whether an error occurred</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspResult">manipulation_msgs/GraspResult</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>SUCCESS</td><td></td></tr>
<tr><td>int32</td><td>GRASP_OUT_OF_REACH</td><td></td></tr>
<tr><td>int32</td><td>GRASP_IN_COLLISION</td><td></td></tr>
<tr><td>int32</td><td>GRASP_UNFEASIBLE</td><td></td></tr>
<tr><td>int32</td><td>PREGRASP_OUT_OF_REACH</td><td></td></tr>
<tr><td>int32</td><td>PREGRASP_IN_COLLISION</td><td></td></tr>
<tr><td>int32</td><td>PREGRASP_UNFEASIBLE</td><td></td></tr>
<tr><td>int32</td><td>LIFT_OUT_OF_REACH</td><td></td></tr>
<tr><td>int32</td><td>LIFT_IN_COLLISION</td><td></td></tr>
<tr><td>int32</td><td>LIFT_UNFEASIBLE</td><td></td></tr>
<tr><td>int32</td><td>MOVE_ARM_FAILED</td><td></td></tr>
<tr><td>int32</td><td>GRASP_FAILED</td><td></td></tr>
<tr><td>int32</td><td>LIFT_FAILED</td><td></td></tr>
<tr><td>int32</td><td>RETREAT_FAILED</td><td></td></tr>
<tr><td>int32</td><td>result_code</td><td></td></tr>
<tr><td>bool</td><td>continuation_possible</td><td>  whether the state of the world was disturbed by this attempt. generally, this flag  shows if another task can be attempted, or a new sensed world model is recommeded  before proceeding</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspableObject">manipulation_msgs/GraspableObject</A></h2>
<table class="altrowstable"">
<p>  an object that the object_manipulator can work on</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>reference_frame_id</td><td>  a graspable object can be represented in multiple ways. This message  can contain all of them. Which one is actually used is up to the receiver  of this message. When adding new representations, one must be careful that  they have reasonable lightweight defaults indicating that that particular  representation is not available.  the tf frame to be used as a reference frame when combining information from  the different representations below</td></tr>
<tr><td><A HREF="#household_objects_database_msgs_DatabaseModelPose">household_objects_database_msgs/DatabaseModelPose[]</A></td><td>potential_models</td><td>  potential recognition results from a database of models  all poses are relative to the object reference pose</td></tr>
<tr><td><A HREF="#sensor_msgs_PointCloud">sensor_msgs/PointCloud</A></td><td>cluster</td><td>  the point cloud itself</td></tr>
<tr><td><A HREF="#manipulation_msgs_SceneRegion">SceneRegion</A></td><td>region</td><td>  a region of a PointCloud2 of interest</td></tr>
<tr><td>string</td><td>collision_name</td><td>  the name that this object has in the collision environment</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GraspableObjectList">manipulation_msgs/GraspableObjectList</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#manipulation_msgs_GraspableObject">manipulation_msgs/GraspableObject[]</A></td><td>graspable_objects</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_Image">sensor_msgs/Image</A></td><td>image</td><td> Information required for visualization</td></tr>
<tr><td><A HREF="#sensor_msgs_CameraInfo">sensor_msgs/CameraInfo</A></td><td>camera_info</td><td></td></tr>
<tr><td><A HREF="#shape_msgs_Mesh">shape_msgs/Mesh[]</A></td><td>meshes</td><td> Holds a single mesh for each recognized graspable object, an empty mesh otherwise</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>reference_to_camera</td><td> pose to transform the frame of the clusters/object poses into camera coordinates</td></tr>
</table>
<h2><A NAME="manipulation_msgs_GripperTranslation">manipulation_msgs/GripperTranslation</A></h2>
<table class="altrowstable"">
<p>  defines a translation for the gripper, used in pickup or place tasks  for example for lifting an object off a table or approaching the table for placing</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Vector3Stamped">geometry_msgs/Vector3Stamped</A></td><td>direction</td><td>  the direction of the translation</td></tr>
<tr><td>float32</td><td>desired_distance</td><td>  the desired translation distance</td></tr>
<tr><td>float32</td><td>min_distance</td><td>  the min distance that must be considered feasible before the  grasp is even attempted</td></tr>
</table>
<h2><A NAME="manipulation_msgs_ManipulationPhase">manipulation_msgs/ManipulationPhase</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>CHECKING_FEASIBILITY</td><td></td></tr>
<tr><td>int32</td><td>MOVING_TO_PREGRASP</td><td></td></tr>
<tr><td>int32</td><td>MOVING_TO_GRASP</td><td></td></tr>
<tr><td>int32</td><td>CLOSING</td><td></td></tr>
<tr><td>int32</td><td>ADJUSTING_GRASP</td><td></td></tr>
<tr><td>int32</td><td>LIFTING</td><td></td></tr>
<tr><td>int32</td><td>MOVING_WITH_OBJECT</td><td></td></tr>
<tr><td>int32</td><td>MOVING_TO_PLACE</td><td></td></tr>
<tr><td>int32</td><td>PLACING</td><td></td></tr>
<tr><td>int32</td><td>OPENING</td><td></td></tr>
<tr><td>int32</td><td>RETREATING</td><td></td></tr>
<tr><td>int32</td><td>MOVING_WITHOUT_OBJECT</td><td></td></tr>
<tr><td>int32</td><td>SHAKING</td><td></td></tr>
<tr><td>int32</td><td>SUCCEEDED</td><td></td></tr>
<tr><td>int32</td><td>FAILED</td><td></td></tr>
<tr><td>int32</td><td>ABORTED</td><td></td></tr>
<tr><td>int32</td><td>HOLDING_OBJECT</td><td></td></tr>
<tr><td>int32</td><td>phase</td><td></td></tr>
</table>
<h2><A NAME="manipulation_msgs_ManipulationResult">manipulation_msgs/ManipulationResult</A></h2>
<table class="altrowstable"">
<p>  Result codes for manipulation tasks</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>SUCCESS</td><td>  task completed as expected  generally means you can proceed as planned</td></tr>
<tr><td>int32</td><td>UNFEASIBLE</td><td>  task not possible (e.g. out of reach or obstacles in the way)  generally means that the world was not disturbed, so you can try another task</td></tr>
<tr><td>int32</td><td>FAILED</td><td>  task was thought possible, but failed due to unexpected events during execution  it is likely that the world was disturbed, so you are encouraged to refresh  your sensed world model before proceeding to another task</td></tr>
<tr><td>int32</td><td>ERROR</td><td>  a lower level error prevented task completion (e.g. joint controller not responding)  generally requires human attention</td></tr>
<tr><td>int32</td><td>ARM_MOVEMENT_PREVENTED</td><td>  means that at some point during execution we ended up in a state that the collision-aware  arm navigation module will not move out of. The world was likely not disturbed, but you  probably need a new collision map to move the arm out of the stuck position</td></tr>
<tr><td>int32</td><td>LIFT_FAILED</td><td>  specific to grasp actions  the object was grasped successfully, but the lift attempt could not achieve the minimum lift distance requested  it is likely that the collision environment will see collisions between the hand/object and the support surface</td></tr>
<tr><td>int32</td><td>RETREAT_FAILED</td><td>  specific to place actions  the object was placed successfully, but the retreat attempt could not achieve the minimum retreat distance requested  it is likely that the collision environment will see collisions between the hand and the object</td></tr>
<tr><td>int32</td><td>CANCELLED</td><td>  indicates that somewhere along the line a human said "wait, stop, this is bad, go back and do something else"</td></tr>
<tr><td>int32</td><td>value</td><td>  the actual value of this error code</td></tr>
</table>
<h2><A NAME="manipulation_msgs_PlaceLocation">manipulation_msgs/PlaceLocation</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>id</td><td>  A name for this grasp</td></tr>
<tr><td><A HREF="#sensor_msgs_JointState">sensor_msgs/JointState</A></td><td>post_place_posture</td><td>  The internal posture of the hand for the grasp  positions and efforts are used</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>place_pose</td><td>  The position of the end-effector for the grasp relative to a reference frame  (that is always specified elsewhere, not in this message)</td></tr>
<tr><td><A HREF="#manipulation_msgs_GripperTranslation">GripperTranslation</A></td><td>approach</td><td>  The approach motion</td></tr>
<tr><td><A HREF="#manipulation_msgs_GripperTranslation">GripperTranslation</A></td><td>retreat</td><td>  The retreat motion</td></tr>
<tr><td>string[]</td><td>allowed_touch_objects</td><td>  an optional list of obstacles that we have semantic information about  and that can be touched/pushed/moved in the course of grasping</td></tr>
</table>
<h2><A NAME="manipulation_msgs_PlaceLocationResult">manipulation_msgs/PlaceLocationResult</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>SUCCESS</td><td></td></tr>
<tr><td>int32</td><td>PLACE_OUT_OF_REACH</td><td></td></tr>
<tr><td>int32</td><td>PLACE_IN_COLLISION</td><td></td></tr>
<tr><td>int32</td><td>PLACE_UNFEASIBLE</td><td></td></tr>
<tr><td>int32</td><td>PREPLACE_OUT_OF_REACH</td><td></td></tr>
<tr><td>int32</td><td>PREPLACE_IN_COLLISION</td><td></td></tr>
<tr><td>int32</td><td>PREPLACE_UNFEASIBLE</td><td></td></tr>
<tr><td>int32</td><td>RETREAT_OUT_OF_REACH</td><td></td></tr>
<tr><td>int32</td><td>RETREAT_IN_COLLISION</td><td></td></tr>
<tr><td>int32</td><td>RETREAT_UNFEASIBLE</td><td></td></tr>
<tr><td>int32</td><td>MOVE_ARM_FAILED</td><td></td></tr>
<tr><td>int32</td><td>PLACE_FAILED</td><td></td></tr>
<tr><td>int32</td><td>RETREAT_FAILED</td><td></td></tr>
<tr><td>int32</td><td>result_code</td><td></td></tr>
<tr><td>bool</td><td>continuation_possible</td><td>  whether the state of the world was disturbed by this attempt. generally, this flag  shows if another task can be attempted, or a new sensed world model is recommeded  before proceeding</td></tr>
</table>
<h2><A NAME="manipulation_msgs_SceneRegion">manipulation_msgs/SceneRegion</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#sensor_msgs_PointCloud2">sensor_msgs/PointCloud2</A></td><td>cloud</td><td>  Point cloud</td></tr>
<tr><td>int32[]</td><td>mask</td><td>  Indices for the region of interest</td></tr>
<tr><td><A HREF="#sensor_msgs_Image">sensor_msgs/Image</A></td><td>image</td><td>  One of the corresponding 2D images, if applicable</td></tr>
<tr><td><A HREF="#sensor_msgs_Image">sensor_msgs/Image</A></td><td>disparity_image</td><td>  The disparity image, if applicable</td></tr>
<tr><td><A HREF="#sensor_msgs_CameraInfo">sensor_msgs/CameraInfo</A></td><td>cam_info</td><td>  Camera info for the camera that took the image</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>roi_box_pose</td><td>  a 3D region of interest for grasp planning</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>roi_box_dims</td><td></td></tr>
</table>
<h1>map_msgs</h1>
<h2><A NAME="map_msgs_OccupancyGridUpdate">map_msgs/OccupancyGridUpdate</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>int32</td><td>x</td><td></td></tr>
<tr><td>int32</td><td>y</td><td></td></tr>
<tr><td>uint32</td><td>width</td><td></td></tr>
<tr><td>uint32</td><td>height</td><td></td></tr>
<tr><td>int8[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="map_msgs_PointCloud2Update">map_msgs/PointCloud2Update</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32</td><td>ADD=0</td><td></td></tr>
<tr><td>uint32</td><td>DELETE=1</td><td></td></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>uint32</td><td>type</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_PointCloud2">sensor_msgs/PointCloud2</A></td><td>points</td><td></td></tr>
</table>
<h2><A NAME="map_msgs_ProjectedMap">map_msgs/ProjectedMap</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#nav_msgs_OccupancyGrid">nav_msgs/OccupancyGrid</A></td><td>map</td><td></td></tr>
<tr><td>float64</td><td>min_z</td><td></td></tr>
<tr><td>float64</td><td>max_z</td><td></td></tr>
</table>
<h2><A NAME="map_msgs_ProjectedMapInfo">map_msgs/ProjectedMapInfo</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>frame_id</td><td></td></tr>
<tr><td>float64</td><td>x</td><td></td></tr>
<tr><td>float64</td><td>y</td><td></td></tr>
<tr><td>float64</td><td>width</td><td></td></tr>
<tr><td>float64</td><td>height</td><td></td></tr>
<tr><td>float64</td><td>min_z</td><td></td></tr>
<tr><td>float64</td><td>max_z</td><td></td></tr>
</table>
<h1>moveit_msgs</h1>
<h2><A NAME="moveit_msgs_AllowedCollisionEntry">moveit_msgs/AllowedCollisionEntry</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>bool[]</td><td>enabled</td><td>  whether or not collision checking is enabled</td></tr>
</table>
<h2><A NAME="moveit_msgs_AllowedCollisionMatrix">moveit_msgs/AllowedCollisionMatrix</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string[]</td><td>entry_names</td><td>  The list of entry names in the matrix</td></tr>
<tr><td><A HREF="#moveit_msgs_AllowedCollisionEntry">AllowedCollisionEntry[]</A></td><td>entry_values</td><td>  The individual entries in the allowed collision matrix  square, symmetric, with same order as entry_names</td></tr>
<tr><td>string[]</td><td>default_entry_names</td><td>  In addition to the collision matrix itself, we also have  the default entry value for each entry name.  If the allowed collision flag is queried for a pair of names (n1, n2)  that is not found in the collision matrix itself, the value of  the collision flag is considered to be that of the entry (n1 or n2)  specified in the list below. If both n1 and n2 are found in the list  of defaults, the result is computed with an AND operation</td></tr>
<tr><td>bool[]</td><td>default_entry_values</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_AttachedCollisionObject">moveit_msgs/AttachedCollisionObject</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>link_name</td><td>  The CollisionObject will be attached with a fixed joint to this link</td></tr>
<tr><td><A HREF="#moveit_msgs_CollisionObject">CollisionObject</A></td><td>object</td><td> This contains the actual shapes and poses for the CollisionObject to be attached to the link If action is remove and no object.id is set, all objects attached to the link indicated by link_name will be removed</td></tr>
<tr><td>string[]</td><td>touch_links</td><td>  The set of links that the attached objects are allowed to touch  by default - the link_name is already considered by default</td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>detach_posture</td><td>  If certain links were placed in a particular posture for this object to remain attached  (e.g., an end effector closing around an object), the posture necessary for releasing  the object is stored here</td></tr>
<tr><td>float64</td><td>weight</td><td>  The weight of the attached object, if known</td></tr>
</table>
<h2><A NAME="moveit_msgs_BoundingVolume">moveit_msgs/BoundingVolume</A></h2>
<table class="altrowstable"">
<p>  Define a volume in 3D</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#shape_msgs_SolidPrimitive">shape_msgs/SolidPrimitive[]</A></td><td>primitives</td><td>  A set of solid geometric primitives that make up the volume to define (as a union)</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>primitive_poses</td><td>  The poses at which the primitives are located</td></tr>
<tr><td><A HREF="#shape_msgs_Mesh">shape_msgs/Mesh[]</A></td><td>meshes</td><td>  In addition to primitives, meshes can be specified to add to the bounding volume (again, as union)</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>mesh_poses</td><td>  The poses at which the meshes are located</td></tr>
</table>
<h2><A NAME="moveit_msgs_CollisionObject">moveit_msgs/CollisionObject</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  a header, used for interpreting the poses</td></tr>
<tr><td>string</td><td>id</td><td>  the id of the object (name used in MoveIt)</td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectType">object_recognition_msgs/ObjectType</A></td><td>type</td><td>  The object type in a database of known objects</td></tr>
<tr><td><A HREF="#shape_msgs_SolidPrimitive">shape_msgs/SolidPrimitive[]</A></td><td>primitives</td><td>  the the collision geometries associated with the object;  their poses are with respect to the specified header  solid geometric primitives</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>primitive_poses</td><td></td></tr>
<tr><td><A HREF="#shape_msgs_Mesh">shape_msgs/Mesh[]</A></td><td>meshes</td><td>  meshes</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>mesh_poses</td><td></td></tr>
<tr><td><A HREF="#shape_msgs_Plane">shape_msgs/Plane[]</A></td><td>planes</td><td>  bounding planes (equation is specified, but the plane can be oriented using an additional pose)</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose[]</A></td><td>plane_poses</td><td></td></tr>
<tr><td>byte</td><td>ADD=0</td><td>  Adds the object to the planning scene. If the object previously existed, it is replaced.</td></tr>
<tr><td>byte</td><td>REMOVE=1</td><td>  Removes the object from the environment entirely (everything that matches the specified id)</td></tr>
<tr><td>byte</td><td>APPEND=2</td><td>  Append to an object that already exists in the planning scene. If the does not exist, it is added.</td></tr>
<tr><td>byte</td><td>MOVE=3</td><td>  If an object already exists in the scene, new poses can be sent (the geometry arrays must be left empty)  if solely moving the object is desired</td></tr>
<tr><td>byte</td><td>operation</td><td>  Operation to be performed</td></tr>
</table>
<h2><A NAME="moveit_msgs_ConstraintEvalResult">moveit_msgs/ConstraintEvalResult</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>bool</td><td>result</td><td>  This message contains result from constraint evaluation  result specifies the result of constraint evaluation   (true indicates state satisfies constraint, false indicates state violates constraint)  if false, distance specifies a measure of the distance of the state from the constraint  if true, distance is set to zero</td></tr>
<tr><td>float64</td><td>distance</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_Constraints">moveit_msgs/Constraints</A></h2>
<table class="altrowstable"">
<p>  This message contains a list of motion planning constraints.  All constraints must be satisfied for a goal to be considered valid</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_JointConstraint">JointConstraint[]</A></td><td>joint_constraints</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PositionConstraint">PositionConstraint[]</A></td><td>position_constraints</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_OrientationConstraint">OrientationConstraint[]</A></td><td>orientation_constraints</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_VisibilityConstraint">VisibilityConstraint[]</A></td><td>visibility_constraints</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_ContactInformation">moveit_msgs/ContactInformation</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Standard ROS header contains information   about the frame in which this   contact is specified</td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point</A></td><td>position</td><td>  Position of the contact point</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>normal</td><td>  Normal corresponding to the contact point</td></tr>
<tr><td>float64</td><td>depth</td><td>  Depth of contact point</td></tr>
<tr><td>string</td><td>contact_body_1</td><td>  Name of the first body that is in contact  This could be a link or a namespace that represents a body</td></tr>
<tr><td>uint32</td><td>body_type_1</td><td></td></tr>
<tr><td>string</td><td>contact_body_2</td><td>  Name of the second body that is in contact  This could be a link or a namespace that represents a body</td></tr>
<tr><td>uint32</td><td>body_type_2</td><td></td></tr>
<tr><td>uint32</td><td>ROBOT_LINK=0</td><td></td></tr>
<tr><td>uint32</td><td>WORLD_OBJECT=1</td><td></td></tr>
<tr><td>uint32</td><td>ROBOT_ATTACHED=2</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_CostSource">moveit_msgs/CostSource</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>cost_density</td><td>  The density of the cost source</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>aabb_min</td><td>  The volume of the cost source is represented as an  axis-aligned bounding box (AABB)  The AABB is specified by two of its opposite corners</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>aabb_max</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_DisplayRobotState">moveit_msgs/DisplayRobotState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>state</td><td>  The robot state to display</td></tr>
<tr><td><A HREF="#moveit_msgs_ObjectColor">ObjectColor[]</A></td><td>highlight_links</td><td>  Optionally, various links can be highlighted</td></tr>
</table>
<h2><A NAME="moveit_msgs_DisplayTrajectory">moveit_msgs/DisplayTrajectory</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>model_id</td><td>  The model id for which this path has been generated</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">RobotTrajectory[]</A></td><td>trajectory</td><td>  The representation of the path contains position values for all the joints that are moving along the path; a sequence of trajectories may be specified</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>trajectory_start</td><td>  The robot state is used to obtain positions for all/some of the joints of the robot.  It is used by the path display node to determine the positions of the joints that are not specified in the joint path message above.  If the robot state message contains joint position information for joints that are also mentioned in the joint path message, the positions in the joint path message will overwrite the positions specified in the robot state message.</td></tr>
</table>
<h2><A NAME="moveit_msgs_Grasp">moveit_msgs/Grasp</A></h2>
<table class="altrowstable"">
<p>  This message contains a description of a grasp that would be used  with a particular end-effector to grasp an object, including how to  approach it, grip it, etc.  This message does not contain any  information about a "grasp point" (a position ON the object).  Whatever generates this message should have already combined  information about grasp points with information about the geometry  of the end-effector to compute the grasp_pose in this message.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>id</td><td>  A name for this grasp</td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>pre_grasp_posture</td><td>  The internal posture of the hand for the pre-grasp  only positions are used</td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>grasp_posture</td><td>  The internal posture of the hand for the grasp  positions and efforts are used</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>grasp_pose</td><td>  The position of the end-effector for the grasp.  This is the pose of  the "parent_link" of the end-effector, not actually the pose of any  link *in* the end-effector.  Typically this would be the pose of the  most distal wrist link before the hand (end-effector) links began.</td></tr>
<tr><td>float64</td><td>grasp_quality</td><td>  The estimated probability of success for this grasp, or some other  measure of how "good" it is.</td></tr>
<tr><td><A HREF="#moveit_msgs_GripperTranslation">GripperTranslation</A></td><td>pre_grasp_approach</td><td>  The approach direction to take before picking an object</td></tr>
<tr><td><A HREF="#moveit_msgs_GripperTranslation">GripperTranslation</A></td><td>post_grasp_retreat</td><td>  The retreat direction to take after a grasp has been completed (object is attached)</td></tr>
<tr><td><A HREF="#moveit_msgs_GripperTranslation">GripperTranslation</A></td><td>post_place_retreat</td><td>  The retreat motion to perform when releasing the object; this information  is not necessary for the grasp itself, but when releasing the object,  the information will be necessary. The grasp used to perform a pickup  is returned as part of the result, so this information is available for  later use.</td></tr>
<tr><td>float32</td><td>max_contact_force</td><td>  the maximum contact force to use while grasping (<=0 to disable)</td></tr>
<tr><td>string[]</td><td>allowed_touch_objects</td><td>  an optional list of obstacles that we have semantic information about  and that can be touched/pushed/moved in the course of grasping</td></tr>
</table>
<h2><A NAME="moveit_msgs_GripperTranslation">moveit_msgs/GripperTranslation</A></h2>
<table class="altrowstable"">
<p>  defines a translation for the gripper, used in pickup or place tasks  for example for lifting an object off a table or approaching the table for placing</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Vector3Stamped">geometry_msgs/Vector3Stamped</A></td><td>direction</td><td>  the direction of the translation</td></tr>
<tr><td>float32</td><td>desired_distance</td><td>  the desired translation distance</td></tr>
<tr><td>float32</td><td>min_distance</td><td>  the min distance that must be considered feasible before the  grasp is even attempted</td></tr>
</table>
<h2><A NAME="moveit_msgs_JointConstraint">moveit_msgs/JointConstraint</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>joint_name</td><td>  Constrain the position of a joint to be within a certain bound</td></tr>
<tr><td>float64</td><td>position</td><td>  the bound to be achieved is [position - tolerance_below, position + tolerance_above]</td></tr>
<tr><td>float64</td><td>tolerance_above</td><td></td></tr>
<tr><td>float64</td><td>tolerance_below</td><td></td></tr>
<tr><td>float64</td><td>weight</td><td>  A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important)</td></tr>
</table>
<h2><A NAME="moveit_msgs_JointLimits">moveit_msgs/JointLimits</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>joint_name</td><td>  This message contains information about limits of a particular joint (or control dimension)</td></tr>
<tr><td>bool</td><td>has_position_limits</td><td>  true if the joint has position limits</td></tr>
<tr><td>float64</td><td>min_position</td><td>  min and max position limits</td></tr>
<tr><td>float64</td><td>max_position</td><td></td></tr>
<tr><td>bool</td><td>has_velocity_limits</td><td>  true if joint has velocity limits</td></tr>
<tr><td>float64</td><td>max_velocity</td><td>  max velocity limit</td></tr>
<tr><td>bool</td><td>has_acceleration_limits</td><td>  min_velocity is assumed to be -max_velocity  true if joint has acceleration limits</td></tr>
<tr><td>float64</td><td>max_acceleration</td><td>  max acceleration limit</td></tr>
</table>
<h2><A NAME="moveit_msgs_KinematicSolverInfo">moveit_msgs/KinematicSolverInfo</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string[]</td><td>joint_names</td><td>  A list of joints in the kinematic tree</td></tr>
<tr><td><A HREF="#moveit_msgs_JointLimits">moveit_msgs/JointLimits[]</A></td><td>limits</td><td>  A list of joint limits corresponding to the joint names</td></tr>
<tr><td>string[]</td><td>link_names</td><td>  A list of links that the kinematics node provides solutions for</td></tr>
</table>
<h2><A NAME="moveit_msgs_LinkPadding">moveit_msgs/LinkPadding</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>link_name</td><td> name for the link</td></tr>
<tr><td>float64</td><td>padding</td><td>  padding to apply to the link</td></tr>
</table>
<h2><A NAME="moveit_msgs_LinkScale">moveit_msgs/LinkScale</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>link_name</td><td> name for the link</td></tr>
<tr><td>float64</td><td>scale</td><td>  scaling to apply to the link</td></tr>
</table>
<h2><A NAME="moveit_msgs_MotionPlanDetailedResponse">moveit_msgs/MotionPlanDetailedResponse</A></h2>
<table class="altrowstable"">
<p>  The representation of a solution to a planning problem, including intermediate data</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>trajectory_start</td><td>  The starting state considered for the robot solution path</td></tr>
<tr><td>string</td><td>group_name</td><td>  The group used for planning (usually the same as in the request)</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">RobotTrajectory[]</A></td><td>trajectory</td><td>  Multiple solution paths are reported, each reflecting intermediate steps in the trajectory processing  The list of reported trajectories</td></tr>
<tr><td>string[]</td><td>description</td><td>  Description of the reported trajectories (name of processing step)</td></tr>
<tr><td>float64[]</td><td>processing_time</td><td>  The amount of time spent computing a particular step in motion plan computation</td></tr>
<tr><td><A HREF="#moveit_msgs_MoveItErrorCodes">MoveItErrorCodes</A></td><td>error_code</td><td>  Status at the end of this plan</td></tr>
</table>
<h2><A NAME="moveit_msgs_MotionPlanRequest">moveit_msgs/MotionPlanRequest</A></h2>
<table class="altrowstable"">
<p>  This service contains the definition for a request to the motion  planner and the output it provides</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_WorkspaceParameters">WorkspaceParameters</A></td><td>workspace_parameters</td><td>  Parameters for the workspace that the planner should work inside</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>start_state</td><td>  Starting state updates. If certain joints should be considered  at positions other than the current ones, these positions should  be set here</td></tr>
<tr><td><A HREF="#moveit_msgs_Constraints">Constraints[]</A></td><td>goal_constraints</td><td>  The possible goal states for the model to plan for. Each element of  the array defines a goal region. The goal is achieved  if the constraints for a particular region are satisfied</td></tr>
<tr><td><A HREF="#moveit_msgs_Constraints">Constraints</A></td><td>path_constraints</td><td>  No state at any point along the path in the produced motion plan will violate these constraints (this applies to all points, not just waypoints)</td></tr>
<tr><td><A HREF="#moveit_msgs_TrajectoryConstraints">TrajectoryConstraints</A></td><td>trajectory_constraints</td><td>  The constraints the resulting trajectory must satisfy</td></tr>
<tr><td>string</td><td>planner_id</td><td>  The name of the motion planner to use. If no name is specified,  a default motion planner will be used</td></tr>
<tr><td>string</td><td>group_name</td><td>  The name of the group of joints on which this planner is operating</td></tr>
<tr><td>int32</td><td>num_planning_attempts</td><td>  The number of times this plan is to be computed. Shortest solution  will be reported.</td></tr>
<tr><td>float64</td><td>allowed_planning_time</td><td>  The maximum amount of time the motion planner is allowed to plan for (in seconds)</td></tr>
<tr><td>float64</td><td>max_velocity_scaling_factor</td><td>  The scaling factor for optionally reducing the maximum joint velocities.  Allowed values are in (0,1]. The maximum joint velocity specified  in the robot model is multiplied by the factor. If outside valid range  (imporantly, this includes it being set to 0.0), the factor is set to a  default value of 1.0 internally (i.e. maximum joint velocity)</td></tr>
</table>
<h2><A NAME="moveit_msgs_MotionPlanResponse">moveit_msgs/MotionPlanResponse</A></h2>
<table class="altrowstable"">
<p>  The representation of a solution to a planning problem</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>trajectory_start</td><td>  The corresponding robot state</td></tr>
<tr><td>string</td><td>group_name</td><td>  The group used for planning (usually the same as in the request)</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">RobotTrajectory</A></td><td>trajectory</td><td>  A solution trajectory, if found</td></tr>
<tr><td>float64</td><td>planning_time</td><td>  Planning time (seconds)</td></tr>
<tr><td><A HREF="#moveit_msgs_MoveItErrorCodes">MoveItErrorCodes</A></td><td>error_code</td><td>  Error code - encodes the overall reason for failure</td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupAction">moveit_msgs/MoveGroupAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_MoveGroupActionGoal">MoveGroupActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_MoveGroupActionResult">MoveGroupActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_MoveGroupActionFeedback">MoveGroupActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupActionFeedback">moveit_msgs/MoveGroupActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_MoveGroupFeedback">MoveGroupFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupActionGoal">moveit_msgs/MoveGroupActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_MoveGroupGoal">MoveGroupGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupActionResult">moveit_msgs/MoveGroupActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_MoveGroupResult">MoveGroupResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupFeedback">moveit_msgs/MoveGroupFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>state</td><td>  The internal state that the move group action currently is in</td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupGoal">moveit_msgs/MoveGroupGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  Motion planning request to pass to planner</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_MotionPlanRequest">MotionPlanRequest</A></td><td>request</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlanningOptions">PlanningOptions</A></td><td>planning_options</td><td>  Planning options</td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveGroupResult">moveit_msgs/MoveGroupResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_MoveItErrorCodes">MoveItErrorCodes</A></td><td>error_code</td><td>  An error code reflecting what went wrong</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">moveit_msgs/RobotState</A></td><td>trajectory_start</td><td>  The full starting state of the robot at the start of the trajectory</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">moveit_msgs/RobotTrajectory</A></td><td>planned_trajectory</td><td>  The trajectory that moved group produced for execution</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">moveit_msgs/RobotTrajectory</A></td><td>executed_trajectory</td><td>  The trace of the trajectory recorded during execution</td></tr>
<tr><td>float64</td><td>planning_time</td><td>  The amount of time it took to complete the motion plan</td></tr>
</table>
<h2><A NAME="moveit_msgs_MoveItErrorCodes">moveit_msgs/MoveItErrorCodes</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>val</td><td></td></tr>
<tr><td>int32</td><td>SUCCESS=1</td><td>  overall behavior</td></tr>
<tr><td>int32</td><td>FAILURE=99999</td><td></td></tr>
<tr><td>int32</td><td>PLANNING_FAILED=-1</td><td></td></tr>
<tr><td>int32</td><td>INVALID_MOTION_PLAN=-2</td><td></td></tr>
<tr><td>int32</td><td>MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE=-3</td><td></td></tr>
<tr><td>int32</td><td>CONTROL_FAILED=-4</td><td></td></tr>
<tr><td>int32</td><td>UNABLE_TO_AQUIRE_SENSOR_DATA=-5</td><td></td></tr>
<tr><td>int32</td><td>TIMED_OUT=-6</td><td></td></tr>
<tr><td>int32</td><td>PREEMPTED=-7</td><td></td></tr>
<tr><td>int32</td><td>START_STATE_IN_COLLISION=-10</td><td>  planning & kinematics request errors</td></tr>
<tr><td>int32</td><td>START_STATE_VIOLATES_PATH_CONSTRAINTS=-11</td><td></td></tr>
<tr><td>int32</td><td>GOAL_IN_COLLISION=-12</td><td></td></tr>
<tr><td>int32</td><td>GOAL_VIOLATES_PATH_CONSTRAINTS=-13</td><td></td></tr>
<tr><td>int32</td><td>GOAL_CONSTRAINTS_VIOLATED=-14</td><td></td></tr>
<tr><td>int32</td><td>INVALID_GROUP_NAME=-15</td><td></td></tr>
<tr><td>int32</td><td>INVALID_GOAL_CONSTRAINTS=-16</td><td></td></tr>
<tr><td>int32</td><td>INVALID_ROBOT_STATE=-17</td><td></td></tr>
<tr><td>int32</td><td>INVALID_LINK_NAME=-18</td><td></td></tr>
<tr><td>int32</td><td>INVALID_OBJECT_NAME=-19</td><td></td></tr>
<tr><td>int32</td><td>FRAME_TRANSFORM_FAILURE=-21</td><td>  system errors</td></tr>
<tr><td>int32</td><td>COLLISION_CHECKING_UNAVAILABLE=-22</td><td></td></tr>
<tr><td>int32</td><td>ROBOT_STATE_STALE=-23</td><td></td></tr>
<tr><td>int32</td><td>SENSOR_INFO_STALE=-24</td><td></td></tr>
<tr><td>int32</td><td>NO_IK_SOLUTION=-31</td><td>  kinematics errors</td></tr>
</table>
<h2><A NAME="moveit_msgs_ObjectColor">moveit_msgs/ObjectColor</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>id</td><td>  The object id for which we specify color</td></tr>
<tr><td><A HREF="#std_msgs_ColorRGBA">std_msgs/ColorRGBA</A></td><td>color</td><td>  The value of the color</td></tr>
</table>
<h2><A NAME="moveit_msgs_OrientationConstraint">moveit_msgs/OrientationConstraint</A></h2>
<table class="altrowstable"">
<p>  This message contains the definition of an orientation constraint.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Quaternion">geometry_msgs/Quaternion</A></td><td>orientation</td><td>  The desired orientation of the robot link specified as a quaternion</td></tr>
<tr><td>string</td><td>link_name</td><td>  The robot link this constraint refers to</td></tr>
<tr><td>float64</td><td>absolute_x_axis_tolerance</td><td>  optional axis-angle error tolerances specified</td></tr>
<tr><td>float64</td><td>absolute_y_axis_tolerance</td><td></td></tr>
<tr><td>float64</td><td>absolute_z_axis_tolerance</td><td></td></tr>
<tr><td>float64</td><td>weight</td><td>  A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important)</td></tr>
</table>
<h2><A NAME="moveit_msgs_OrientedBoundingBox">moveit_msgs/OrientedBoundingBox</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td>  the pose of the box</td></tr>
<tr><td><A HREF="#geometry_msgs_Point32">geometry_msgs/Point32</A></td><td>extents</td><td>  the extents of the box, assuming the center is at the origin</td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupAction">moveit_msgs/PickupAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_PickupActionGoal">PickupActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PickupActionResult">PickupActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PickupActionFeedback">PickupActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupActionFeedback">moveit_msgs/PickupActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PickupFeedback">PickupFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupActionGoal">moveit_msgs/PickupActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PickupGoal">PickupGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupActionResult">moveit_msgs/PickupActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PickupResult">PickupResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupFeedback">moveit_msgs/PickupFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>state</td><td>  The internal state that the pickup action currently is in</td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupGoal">moveit_msgs/PickupGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  An action for picking up an object</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>target_name</td><td>  The name of the object to pick up (as known in the planning scene)</td></tr>
<tr><td>string</td><td>group_name</td><td>  which group should be used to plan for pickup</td></tr>
<tr><td>string</td><td>end_effector</td><td>  which end-effector to be used for pickup (ideally descending from the group above)</td></tr>
<tr><td><A HREF="#moveit_msgs_Grasp">Grasp[]</A></td><td>possible_grasps</td><td>  a list of possible grasps to be used. At least one grasp must be filled in</td></tr>
<tr><td>string</td><td>support_surface_name</td><td>  the name that the support surface (e.g. table) has in the collision map  can be left empty if no name is available</td></tr>
<tr><td>bool</td><td>allow_gripper_support_collision</td><td>  whether collisions between the gripper and the support surface should be acceptable  during move from pre-grasp to grasp and during lift. Collisions when moving to the  pre-grasp location are still not allowed even if this is set to true.</td></tr>
<tr><td>string[]</td><td>attached_object_touch_links</td><td>  The names of the links the object to be attached is allowed to touch;  If this is left empty, it defaults to the links in the used end-effector</td></tr>
<tr><td>bool</td><td>minimize_object_distance</td><td>  Optionally notify the pick action that it should approach the object further,  as much as possible (this minimizing the distance to the object before the grasp)  along the approach direction; Note: this option changes the grasping poses  supplied in possible_grasps[] such that they are closer to the object when possible.</td></tr>
<tr><td><A HREF="#moveit_msgs_Constraints">Constraints</A></td><td>path_constraints</td><td>  Optional constraints to be imposed on every point in the motion plan</td></tr>
<tr><td>string</td><td>planner_id</td><td>  The name of the motion planner to use. If no name is specified,  a default motion planner will be used</td></tr>
<tr><td>string[]</td><td>allowed_touch_objects</td><td>  an optional list of obstacles that we have semantic information about  and that can be touched/pushed/moved in the course of grasping;  CAREFUL: If the object name 'all' is used, collisions with all objects are disabled during the approach & lift.</td></tr>
<tr><td>float64</td><td>allowed_planning_time</td><td>  The maximum amount of time the motion planner is allowed to plan for</td></tr>
<tr><td><A HREF="#moveit_msgs_PlanningOptions">PlanningOptions</A></td><td>planning_options</td><td>  Planning options</td></tr>
</table>
<h2><A NAME="moveit_msgs_PickupResult">moveit_msgs/PickupResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_MoveItErrorCodes">MoveItErrorCodes</A></td><td>error_code</td><td>  The overall result of the pickup attempt</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>trajectory_start</td><td>  The full starting state of the robot at the start of the trajectory</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">RobotTrajectory[]</A></td><td>trajectory_stages</td><td>  The trajectory that moved group produced for execution</td></tr>
<tr><td>string[]</td><td>trajectory_descriptions</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_Grasp">Grasp</A></td><td>grasp</td><td>  The performed grasp, if attempt was successful</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceAction">moveit_msgs/PlaceAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_PlaceActionGoal">PlaceActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceActionResult">PlaceActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceActionFeedback">PlaceActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceActionFeedback">moveit_msgs/PlaceActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceFeedback">PlaceFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceActionGoal">moveit_msgs/PlaceActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceGoal">PlaceGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceActionResult">moveit_msgs/PlaceActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceResult">PlaceResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceFeedback">moveit_msgs/PlaceFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>state</td><td>  The internal state that the place action currently is in</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceGoal">moveit_msgs/PlaceGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  An action for placing an object</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>group_name</td><td>  which group to be used to plan for grasping</td></tr>
<tr><td>string</td><td>attached_object_name</td><td>  the name that the attached object to place</td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceLocation">PlaceLocation[]</A></td><td>place_locations</td><td>  a list of possible transformations for placing the object</td></tr>
<tr><td>bool</td><td>place_eef</td><td>  if the user prefers setting the eef pose (same as in pick) rather than  the location of an end effector, this flag should be set to true</td></tr>
<tr><td>string</td><td>support_surface_name</td><td>  the name that the support surface (e.g. table) has in the collision world  can be left empty if no name is available</td></tr>
<tr><td>bool</td><td>allow_gripper_support_collision</td><td>  whether collisions between the gripper and the support surface should be acceptable  during move from pre-place to place and during retreat. Collisions when moving to the  pre-place location are still not allowed even if this is set to true.</td></tr>
<tr><td><A HREF="#moveit_msgs_Constraints">Constraints</A></td><td>path_constraints</td><td>  Optional constraints to be imposed on every point in the motion plan</td></tr>
<tr><td>string</td><td>planner_id</td><td>  The name of the motion planner to use. If no name is specified,  a default motion planner will be used</td></tr>
<tr><td>string[]</td><td>allowed_touch_objects</td><td>  an optional list of obstacles that we have semantic information about  and that can be touched/pushed/moved in the course of grasping;  CAREFUL: If the object name 'all' is used, collisions with all objects are disabled during the approach & lift.</td></tr>
<tr><td>float64</td><td>allowed_planning_time</td><td>  The maximum amount of time the motion planner is allowed to plan for</td></tr>
<tr><td><A HREF="#moveit_msgs_PlanningOptions">PlanningOptions</A></td><td>planning_options</td><td>  Planning options</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceLocation">moveit_msgs/PlaceLocation</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>id</td><td>  A name for this grasp</td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>post_place_posture</td><td>  The internal posture of the hand for the grasp  positions and efforts are used</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>place_pose</td><td>  The position of the end-effector for the grasp relative to a reference frame  (that is always specified elsewhere, not in this message)</td></tr>
<tr><td><A HREF="#moveit_msgs_GripperTranslation">GripperTranslation</A></td><td>pre_place_approach</td><td>  The approach motion</td></tr>
<tr><td><A HREF="#moveit_msgs_GripperTranslation">GripperTranslation</A></td><td>post_place_retreat</td><td>  The retreat motion</td></tr>
<tr><td>string[]</td><td>allowed_touch_objects</td><td>  an optional list of obstacles that we have semantic information about  and that can be touched/pushed/moved in the course of grasping</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlaceResult">moveit_msgs/PlaceResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_MoveItErrorCodes">MoveItErrorCodes</A></td><td>error_code</td><td>  The result of the pickup attempt</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>trajectory_start</td><td>  The full starting state of the robot at the start of the trajectory</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotTrajectory">RobotTrajectory[]</A></td><td>trajectory_stages</td><td>  The trajectory that moved group produced for execution</td></tr>
<tr><td>string[]</td><td>trajectory_descriptions</td><td></td></tr>
<tr><td><A HREF="#moveit_msgs_PlaceLocation">PlaceLocation</A></td><td>place_location</td><td>  The successful place location, if any</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlannerInterfaceDescription">moveit_msgs/PlannerInterfaceDescription</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td>  The name of the planner interface</td></tr>
<tr><td>string[]</td><td>planner_ids</td><td>  The names of the planner ids within the interface</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlanningOptions">moveit_msgs/PlanningOptions</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_PlanningScene">PlanningScene</A></td><td>planning_scene_diff</td><td>  The diff to consider for the planning scene (optional)</td></tr>
<tr><td>bool</td><td>plan_only</td><td>  If this flag is set to true, the action  returns an executable plan in the response but does not attempt execution</td></tr>
<tr><td>bool</td><td>look_around</td><td>  If this flag is set to true, the action of planning &  executing is allowed to look around  (move sensors) if  it seems that not enough information is available about  the environment</td></tr>
<tr><td>int32</td><td>look_around_attempts</td><td>  If this value is positive, the action of planning & executing  is allowed to look around for a maximum number of attempts;  If the value is left as 0, the default value is used, as set  with dynamic_reconfigure</td></tr>
<tr><td>float64</td><td>max_safe_execution_cost</td><td>  If set and if look_around is true, this value is used as  the maximum cost allowed for a path to be considered executable.  If the cost of a path is higher than this value, more sensing or  a new plan needed. If left as 0.0 but look_around is true, then  the default value set via dynamic_reconfigure is used</td></tr>
<tr><td>bool</td><td>replan</td><td>  If the plan becomes invalidated during execution, it is possible to have  that plan recomputed and execution restarted. This flag enables this  functionality</td></tr>
<tr><td>int32</td><td>replan_attempts</td><td>  The maximum number of replanning attempts</td></tr>
<tr><td>float64</td><td>replan_delay</td><td>  The amount of time to wait in between replanning attempts (in seconds)</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlanningScene">moveit_msgs/PlanningScene</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td>  name of planning scene</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">RobotState</A></td><td>robot_state</td><td>  full robot state</td></tr>
<tr><td>string</td><td>robot_model_name</td><td>  The name of the robot model this scene is for</td></tr>
<tr><td><A HREF="#geometry_msgs_TransformStamped">geometry_msgs/TransformStamped[]</A></td><td>fixed_frame_transforms</td><td> additional frames for duplicating tf (with respect to the planning frame)</td></tr>
<tr><td><A HREF="#moveit_msgs_AllowedCollisionMatrix">AllowedCollisionMatrix</A></td><td>allowed_collision_matrix</td><td> full allowed collision matrix</td></tr>
<tr><td><A HREF="#moveit_msgs_LinkPadding">LinkPadding[]</A></td><td>link_padding</td><td>  all link paddings</td></tr>
<tr><td><A HREF="#moveit_msgs_LinkScale">LinkScale[]</A></td><td>link_scale</td><td>  all link scales</td></tr>
<tr><td><A HREF="#moveit_msgs_ObjectColor">ObjectColor[]</A></td><td>object_colors</td><td>  Attached objects, collision objects, even the octomap or collision map can have  colors associated to them. This array specifies them.</td></tr>
<tr><td><A HREF="#moveit_msgs_PlanningSceneWorld">PlanningSceneWorld</A></td><td>world</td><td>  the collision map</td></tr>
<tr><td>bool</td><td>is_diff</td><td>  Flag indicating whether this scene is to be interpreted as a diff with respect to some other scene</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlanningSceneComponents">moveit_msgs/PlanningSceneComponents</A></h2>
<table class="altrowstable"">
<p>  This message defines the components that make up the PlanningScene message.  The values can be used as a bitfield to specify which parts of the PlanningScene message  are of interest</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32</td><td>SCENE_SETTINGS=1</td><td>  Scene name, model name, model root</td></tr>
<tr><td>uint32</td><td>ROBOT_STATE=2</td><td>  Joint values of the robot state</td></tr>
<tr><td>uint32</td><td>ROBOT_STATE_ATTACHED_OBJECTS=4</td><td>  Attached objects (including geometry) for the robot state</td></tr>
<tr><td>uint32</td><td>WORLD_OBJECT_NAMES=8</td><td>  The names of the world objects</td></tr>
<tr><td>uint32</td><td>WORLD_OBJECT_GEOMETRY=16</td><td>  The geometry of the world objects</td></tr>
<tr><td>uint32</td><td>OCTOMAP=32</td><td>  The maintained octomap</td></tr>
<tr><td>uint32</td><td>TRANSFORMS=64</td><td>  The maintained list of transforms</td></tr>
<tr><td>uint32</td><td>ALLOWED_COLLISION_MATRIX=128</td><td>  The allowed collision matrix</td></tr>
<tr><td>uint32</td><td>LINK_PADDING_AND_SCALING=256</td><td>  The default link padding and link scaling</td></tr>
<tr><td>uint32</td><td>OBJECT_COLORS=512</td><td>  The stored object colors</td></tr>
<tr><td>uint32</td><td>components</td><td>  Bitfield combining options indicated above</td></tr>
</table>
<h2><A NAME="moveit_msgs_PlanningSceneWorld">moveit_msgs/PlanningSceneWorld</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_CollisionObject">CollisionObject[]</A></td><td>collision_objects</td><td>  collision objects</td></tr>
<tr><td><A HREF="#octomap_msgs_OctomapWithPose">octomap_msgs/OctomapWithPose</A></td><td>octomap</td><td>  The octomap that represents additional collision data</td></tr>
</table>
<h2><A NAME="moveit_msgs_PositionConstraint">moveit_msgs/PositionConstraint</A></h2>
<table class="altrowstable"">
<p>  This message contains the definition of a position constraint.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string</td><td>link_name</td><td>  The robot link this constraint refers to</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>target_point_offset</td><td>  The offset (in the link frame) for the target point on the link we are planning for</td></tr>
<tr><td><A HREF="#moveit_msgs_BoundingVolume">BoundingVolume</A></td><td>constraint_region</td><td>  The volume this constraint refers to</td></tr>
<tr><td>float64</td><td>weight</td><td>  A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important)</td></tr>
</table>
<h2><A NAME="moveit_msgs_PositionIKRequest">moveit_msgs/PositionIKRequest</A></h2>
<table class="altrowstable"">
<p>  A Position IK request message</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>group_name</td><td>  The name of the group which will be used to compute IK  e.g. "right_arm", or "arms" - see IK specification for multiple-groups below  Information from the SRDF will be used to automatically determine which link  to solve IK for, unless ik_link_name is also specified</td></tr>
<tr><td><A HREF="#moveit_msgs_RobotState">moveit_msgs/RobotState</A></td><td>robot_state</td><td>  A RobotState consisting of hint/seed positions for the IK computation and positions  for all the other joints in the robot. Additional state information provided here is  used to specify starting positions for other joints/links on the robot.  This state MUST contain state for all joints to be used by the IK solver  to compute IK. The list of joints that the IK solver deals with can be  found using the SRDF for the corresponding group</td></tr>
<tr><td><A HREF="#moveit_msgs_Constraints">Constraints</A></td><td>constraints</td><td>  A set of constraints that the IK must obey; by default, this set of constraints is empty</td></tr>
<tr><td>bool</td><td>avoid_collisions</td><td>  Find an IK solution that avoids collisions. By default, this is false</td></tr>
<tr><td>string</td><td>ik_link_name</td><td>  (OPTIONAL) The name of the link for which we are computing IK  If not specified, the link name will be inferred from a combination  of the group name and the SRDF. If any values are specified for ik_link_names,  this value is ignored</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>pose_stamped</td><td>  The stamped pose of the link, when the IK solver computes the joint values  for all the joints in a group. This value is ignored if pose_stamped_vector  has any elements specified.</td></tr>
<tr><td>string[]</td><td>ik_link_names</td><td>  Multi-group parameters  (OPTIONAL) The names of the links for which we are computing IK  If not specified, the link name will be inferred from a combination  of the group name and the SRDF</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped[]</A></td><td>pose_stamped_vector</td><td>  (OPTIONAL) The (stamped) poses of the links we are computing IK for (when a group has more than one end effector)  e.g. The "arms" group might consist of both the "right_arm" and the "left_arm"  The order of the groups referred to is the same as the order setup in the SRDF</td></tr>
<tr><td>duration</td><td>timeout</td><td>  Maximum allowed time for IK calculation</td></tr>
<tr><td>int32</td><td>attempts</td><td>  Maximum number of IK attempts (if using random seeds; leave as 0 for the default value specified on the param server to be used)</td></tr>
</table>
<h2><A NAME="moveit_msgs_RobotState">moveit_msgs/RobotState</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#sensor_msgs_JointState">sensor_msgs/JointState</A></td><td>joint_state</td><td>  This message contains information about the robot state, i.e. the positions of its joints and links</td></tr>
<tr><td><A HREF="#sensor_msgs_MultiDOFJointState">sensor_msgs/MultiDOFJointState</A></td><td>multi_dof_joint_state</td><td>  Joints that may have multiple DOF are specified here</td></tr>
<tr><td><A HREF="#moveit_msgs_AttachedCollisionObject">AttachedCollisionObject[]</A></td><td>attached_collision_objects</td><td>  Attached collision objects (attached to some link on the robot)</td></tr>
<tr><td>bool</td><td>is_diff</td><td>  Flag indicating whether this scene is to be interpreted as a diff with respect to some other scene  This is mostly important for handling the attached bodies (whether or not to clear the attached bodies  of a moveit::core::RobotState before updating it with this message)</td></tr>
</table>
<h2><A NAME="moveit_msgs_RobotTrajectory">moveit_msgs/RobotTrajectory</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></td><td>joint_trajectory</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_MultiDOFJointTrajectory">trajectory_msgs/MultiDOFJointTrajectory</A></td><td>multi_dof_joint_trajectory</td><td></td></tr>
</table>
<h2><A NAME="moveit_msgs_TrajectoryConstraints">moveit_msgs/TrajectoryConstraints</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#moveit_msgs_Constraints">Constraints[]</A></td><td>constraints</td><td>  The array of constraints to consider along the trajectory</td></tr>
</table>
<h2><A NAME="moveit_msgs_VisibilityConstraint">moveit_msgs/VisibilityConstraint</A></h2>
<table class="altrowstable"">
<p>  The constraint is useful to maintain visibility to a disc (the target) in a particular frame.  This disc forms the base of a visibiliy cone whose tip is at the origin of the sensor.  Maintaining visibility is done by ensuring the robot does not obstruct the visibility cone.  Note:  This constraint does NOT enforce minimum or maximum distances between the sensor  and the target, nor does it enforce the target to be in the field of view of  the sensor. A PositionConstraint can (and probably should) be used for such purposes.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>target_radius</td><td>  The radius of the disc that should be maintained visible</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>target_pose</td><td>  The pose of the disc; as the robot moves, the pose of the disc may change as well  This can be in the frame of a particular robot link, for example</td></tr>
<tr><td>int32</td><td>cone_sides</td><td>  From the sensor origin towards the target, the disc forms a visibility cone  This cone is approximated using many sides. For example, when using 4 sides,  that in fact makes the visibility region be a pyramid.  This value should always be 3 or more.</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped</A></td><td>sensor_pose</td><td>  The pose in which visibility is to be maintained.  The frame id should represent the robot link to which the sensor is attached.  It is assumed the sensor can look directly at the target, in any direction.  This assumption is usually not true, but additional PositionConstraints  can resolve this issue.</td></tr>
<tr><td>float64</td><td>max_view_angle</td><td>  Even though the disc is maintained visible, the visibility cone can be very small  because of the orientation of the disc with respect to the sensor. It is possible  for example to view the disk almost from a side, in which case the visibility cone  can end up having close to 0 volume. The view angle is defined to be the angle between  the normal to the visibility disc and the direction vector from the sensor origin.  The value below represents the minimum desired view angle. For a perfect view,  this value will be 0 (the two vectors are exact opposites). For a completely obstructed view  this value will be Pi/2 (the vectors are perpendicular). This value defined below  is the maximum view angle to be maintained. This should be a value in the open interval  (0, Pi/2). If 0 is set, the view angle is NOT enforced.</td></tr>
<tr><td>float64</td><td>max_range_angle</td><td>  This angle is used similarly to max_view_angle but limits the maximum angle  between the sensor origin direction vector and the axis that connects the  sensor origin to the target frame origin. The value is again in the range (0, Pi/2)  and is NOT enforced if set to 0.</td></tr>
<tr><td>uint8</td><td>SENSOR_Z=0</td><td>  The axis that is assumed to indicate the direction of view for the sensor  X = 2, Y = 1, Z = 0</td></tr>
<tr><td>uint8</td><td>SENSOR_Y=1</td><td></td></tr>
<tr><td>uint8</td><td>SENSOR_X=2</td><td></td></tr>
<tr><td>uint8</td><td>sensor_view_direction</td><td></td></tr>
<tr><td>float64</td><td>weight</td><td>  A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important)</td></tr>
</table>
<h2><A NAME="moveit_msgs_WorkspaceParameters">moveit_msgs/WorkspaceParameters</A></h2>
<table class="altrowstable"">
<p>  This message contains a set of parameters useful in  setting up the volume (a box) in which the robot is allowed to move.  This is useful only when planning for mobile parts of   the robot as well.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Define the frame of reference for the box corners</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>min_corner</td><td>  The minumum corner of the box, with respect to the robot starting pose</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>max_corner</td><td>  The maximum corner of the box, with respect to the robot starting pose</td></tr>
</table>
<h1>nav_msgs</h1>
<h2><A NAME="nav_msgs_GetMapAction">nav_msgs/GetMapAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#nav_msgs_GetMapActionGoal">GetMapActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#nav_msgs_GetMapActionResult">GetMapActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#nav_msgs_GetMapActionFeedback">GetMapActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_GetMapActionFeedback">nav_msgs/GetMapActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#nav_msgs_GetMapFeedback">GetMapFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_GetMapActionGoal">nav_msgs/GetMapActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#nav_msgs_GetMapGoal">GetMapGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_GetMapActionResult">nav_msgs/GetMapActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#nav_msgs_GetMapResult">GetMapResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_GetMapFeedback">nav_msgs/GetMapFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  no feedback</p></table>
<h2><A NAME="nav_msgs_GetMapGoal">nav_msgs/GetMapGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  Get the map as a nav_msgs/OccupancyGrid</p></table>
<h2><A NAME="nav_msgs_GetMapResult">nav_msgs/GetMapResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#nav_msgs_OccupancyGrid">nav_msgs/OccupancyGrid</A></td><td>map</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_GridCells">nav_msgs/GridCells</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td> an array of cells in a 2D grid</td></tr>
<tr><td>float32</td><td>cell_width</td><td></td></tr>
<tr><td>float32</td><td>cell_height</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point[]</A></td><td>cells</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_MapMetaData">nav_msgs/MapMetaData</A></h2>
<table class="altrowstable"">
<p>  This hold basic information about the characterists of the OccupancyGrid</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>time</td><td>map_load_time</td><td>  The time at which the map was loaded</td></tr>
<tr><td>float32</td><td>resolution</td><td>  The map resolution [m/cell]</td></tr>
<tr><td>uint32</td><td>width</td><td>  Map width [cells]</td></tr>
<tr><td>uint32</td><td>height</td><td>  Map height [cells]</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>origin</td><td>  The origin of the map [m, m, rad].  This is the real-world pose of the  cell (0,0) in the map.</td></tr>
</table>
<h2><A NAME="nav_msgs_OccupancyGrid">nav_msgs/OccupancyGrid</A></h2>
<table class="altrowstable"">
<p>  This represents a 2-D grid map, in which each cell represents the probability of  occupancy.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#nav_msgs_MapMetaData">MapMetaData</A></td><td>info</td><td> MetaData for the map</td></tr>
<tr><td>int8[]</td><td>data</td><td>  The map data, in row-major order, starting with (0,0).  Occupancy  probabilities are in the range [0,100].  Unknown is -1.</td></tr>
</table>
<h2><A NAME="nav_msgs_Odometry">nav_msgs/Odometry</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This represents an estimate of a position and velocity in free space.    The pose in this message should be specified in the coordinate frame given by header.frame_id.  The twist in this message should be specified in the coordinate frame given by the child_frame_id</td></tr>
<tr><td>string</td><td>child_frame_id</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_PoseWithCovariance">geometry_msgs/PoseWithCovariance</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_TwistWithCovariance">geometry_msgs/TwistWithCovariance</A></td><td>twist</td><td></td></tr>
</table>
<h2><A NAME="nav_msgs_Path">nav_msgs/Path</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td> An array of poses that represents a Path for a robot to follow</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseStamped">geometry_msgs/PoseStamped[]</A></td><td>poses</td><td></td></tr>
</table>
<h1>object_recognition_msgs</h1>
<h2><A NAME="object_recognition_msgs_ObjectInformation">object_recognition_msgs/ObjectInformation</A></h2>
<table class="altrowstable"">
<p>                                               VISUALIZATION INFO                                                                           THIS INFO SHOULD BE OBTAINED INDEPENDENTLY FROM THE CORE, LIKE IN AN RVIZ PLUGIN                    </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td>  The human readable name of the object</td></tr>
<tr><td><A HREF="#shape_msgs_Mesh">shape_msgs/Mesh</A></td><td>ground_truth_mesh</td><td>  The full mesh of the object: this can be useful for display purposes, augmented reality ... but it can be big  Make sure the type is MESH</td></tr>
<tr><td><A HREF="#sensor_msgs_PointCloud2">sensor_msgs/PointCloud2</A></td><td>ground_truth_point_cloud</td><td>  Sometimes, you only have a cloud in the DB  Make sure the type is POINTS</td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionAction">object_recognition_msgs/ObjectRecognitionAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectRecognitionActionGoal">ObjectRecognitionActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectRecognitionActionResult">ObjectRecognitionActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectRecognitionActionFeedback">ObjectRecognitionActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionActionFeedback">object_recognition_msgs/ObjectRecognitionActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectRecognitionFeedback">ObjectRecognitionFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionActionGoal">object_recognition_msgs/ObjectRecognitionActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectRecognitionGoal">ObjectRecognitionGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionActionResult">object_recognition_msgs/ObjectRecognitionActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectRecognitionResult">ObjectRecognitionResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionFeedback">object_recognition_msgs/ObjectRecognitionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ====== no feedback</p></table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionGoal">object_recognition_msgs/ObjectRecognitionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  Optional ROI to use for the object detection</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>bool</td><td>use_roi</td><td></td></tr>
<tr><td>float32[]</td><td>filter_limits</td><td></td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectRecognitionResult">object_recognition_msgs/ObjectRecognitionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======  Send the found objects, see the msg files for docs</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#object_recognition_msgs_RecognizedObjectArray">object_recognition_msgs/RecognizedObjectArray</A></td><td>recognized_objects</td><td></td></tr>
</table>
<h2><A NAME="object_recognition_msgs_ObjectType">object_recognition_msgs/ObjectType</A></h2>
<table class="altrowstable"">
<p>                                                   OBJECT ID                                                          </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>key</td><td>  Contains information about the type of a found object. Those two sets of parameters together uniquely define an  object  The key of the found object: the unique identifier in the given db</td></tr>
<tr><td>string</td><td>db</td><td>  The db parameters stored as a JSON/compressed YAML string. An object id does not make sense without the corresponding  database. E.g., in object_recognition, it can look like: "{'type':'CouchDB', 'root':'http://localhost'}"  There is no conventional format for those parameters and it's nice to keep that flexibility.  The object_recognition_core as a generic DB type that can read those fields  Current examples:  For CouchDB:    type: 'CouchDB'    root: 'http://localhost:5984'    collection: 'object_recognition'  For SQL household database:    type: 'SqlHousehold'    host: 'wgs36'    port: 5432    user: 'willow'    password: 'willow'    name: 'household_objects'    module: 'tabletop'</td></tr>
</table>
<h2><A NAME="object_recognition_msgs_RecognizedObject">object_recognition_msgs/RecognizedObject</A></h2>
<table class="altrowstable"">
<p>                                                      HEADER                                                            </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  The header frame corresponds to the pose frame, NOT the point_cloud frame.</td></tr>
<tr><td><A HREF="#object_recognition_msgs_ObjectType">object_recognition_msgs/ObjectType</A></td><td>type</td><td>                                                   OBJECT INFO                                                            Contains information about the type and the position of a found object  Some of those fields might not be filled because the used techniques do not fill them or because the user does not  request them  The type of the found object</td></tr>
<tr><td>float32</td><td>confidence</td><td> confidence: how sure you are it is that object and not another one.  It is between 0 and 1 and the closer to one it is the better</td></tr>
<tr><td><A HREF="#sensor_msgs_PointCloud2">sensor_msgs/PointCloud2[]</A></td><td>point_clouds</td><td>                                                 OBJECT CLUSTERS                                                          Sometimes you can extract the 3d points that belong to the object, in the frames of the original sensors  (it is an array as you might have several sensors)</td></tr>
<tr><td><A HREF="#shape_msgs_Mesh">shape_msgs/Mesh</A></td><td>bounding_mesh</td><td>  Sometimes, you can only provide a bounding box/shape, even in 3d  This is in the pose frame</td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point[]</A></td><td>bounding_contours</td><td>  Sometimes, you only have 2d input so you can't really give a pose, you just get a contour, or a box  The last point will be linked to the first one automatically</td></tr>
<tr><td><A HREF="#geometry_msgs_PoseWithCovarianceStamped">geometry_msgs/PoseWithCovarianceStamped</A></td><td>pose</td><td>                                                     POSE INFO                                                            This is the result that everybody expects : the pose in some frame given with the input. The units are radian/meters  as usual</td></tr>
</table>
<h2><A NAME="object_recognition_msgs_RecognizedObjectArray">object_recognition_msgs/RecognizedObjectArray</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>                                                      HEADER                                                            </td></tr>
<tr><td><A HREF="#object_recognition_msgs_RecognizedObject">object_recognition_msgs/RecognizedObject[]</A></td><td>objects</td><td>  This message type describes a potential scene configuration: a set of objects that can explain the scene</td></tr>
<tr><td>float32[]</td><td>cooccurrence</td><td>                                                      SEARCH                                                              The co-occurrence matrix between the recognized objects</td></tr>
</table>
<h2><A NAME="object_recognition_msgs_Table">object_recognition_msgs/Table</A></h2>
<table class="altrowstable"">
<p>  Informs that a planar table has been detected at a given location</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td>  The pose gives you the transform that take you to the coordinate system  of the table, with the origin somewhere in the table plane and the  z axis normal to the plane</td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point[]</A></td><td>convex_hull</td><td>  There is no guarantee that the table does NOT extend further than the  convex hull; this is just as far as we've observed it.  The origin of the table coordinate system is inside the convex hull  Set of points forming the convex hull of the table</td></tr>
</table>
<h2><A NAME="object_recognition_msgs_TableArray">object_recognition_msgs/TableArray</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#object_recognition_msgs_Table">object_recognition_msgs/Table[]</A></td><td>tables</td><td>  Just an array of tables</td></tr>
</table>
<h1>octomap_msgs</h1>
<h2><A NAME="octomap_msgs_Octomap">octomap_msgs/Octomap</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  A 3D map in binary format, as Octree</td></tr>
<tr><td>bool</td><td>binary</td><td>  Flag to denote a binary (only free/occupied) or full occupancy octree (.bt/.ot file)</td></tr>
<tr><td>string</td><td>id</td><td>  Class id of the contained octree</td></tr>
<tr><td>float64</td><td>resolution</td><td>  Resolution (in m) of the smallest octree nodes</td></tr>
<tr><td>int8[]</td><td>data</td><td>  binary serialization of octree, use conversions.h to read and write octrees</td></tr>
</table>
<h2><A NAME="octomap_msgs_OctomapWithPose">octomap_msgs/OctomapWithPose</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  A 3D map in binary format, as Octree</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>origin</td><td>  The pose of the octree with respect to the header frame</td></tr>
<tr><td><A HREF="#octomap_msgs_Octomap">octomap_msgs/Octomap</A></td><td>octomap</td><td>  The actual octree msg</td></tr>
</table>
<h1>pcl_msgs</h1>
<h2><A NAME="pcl_msgs_ModelCoefficients">pcl_msgs/ModelCoefficients</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float32[]</td><td>values</td><td></td></tr>
</table>
<h2><A NAME="pcl_msgs_PointIndices">pcl_msgs/PointIndices</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>int32[]</td><td>indices</td><td></td></tr>
</table>
<h2><A NAME="pcl_msgs_PolygonMesh">pcl_msgs/PolygonMesh</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Separate header for the polygonal surface</td></tr>
<tr><td><A HREF="#sensor_msgs_PointCloud2">sensor_msgs/PointCloud2</A></td><td>cloud</td><td>  Vertices of the mesh as a point cloud</td></tr>
<tr><td><A HREF="#pcl_msgs_Vertices">Vertices[]</A></td><td>polygons</td><td>  List of polygons</td></tr>
</table>
<h2><A NAME="pcl_msgs_Vertices">pcl_msgs/Vertices</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32[]</td><td>vertices</td><td>  List of point indices</td></tr>
</table>
<h1>rosgraph_msgs</h1>
<h2><A NAME="rosgraph_msgs_Clock">rosgraph_msgs/Clock</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>time</td><td>clock</td><td>  roslib/Clock is used for publishing simulated time in ROS.   This message simply communicates the current time.  For more information, see http://www.ros.org/wiki/Clock</td></tr>
</table>
<h2><A NAME="rosgraph_msgs_Log">rosgraph_msgs/Log</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>byte</td><td>DEBUG=1</td><td>     Severity level constants  </td></tr>
<tr><td>byte</td><td>INFO=2</td><td></td></tr>
<tr><td>byte</td><td>WARN=4</td><td></td></tr>
<tr><td>byte</td><td>ERROR=8</td><td></td></tr>
<tr><td>byte</td><td>FATAL=16</td><td></td></tr>
<tr><td>Header</td><td>header</td><td>     Fields  </td></tr>
<tr><td>byte</td><td>level</td><td></td></tr>
<tr><td>string</td><td>name</td><td></td></tr>
<tr><td>string</td><td>msg</td><td></td></tr>
<tr><td>string</td><td>file</td><td></td></tr>
<tr><td>string</td><td>function</td><td></td></tr>
<tr><td>uint32</td><td>line</td><td></td></tr>
<tr><td>string[]</td><td>topics</td><td></td></tr>
</table>
<h2><A NAME="rosgraph_msgs_TopicStatistics">rosgraph_msgs/TopicStatistics</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>topic</td><td>  name of the topic</td></tr>
<tr><td>string</td><td>node_pub</td><td>  node id of the publisher</td></tr>
<tr><td>string</td><td>node_sub</td><td>  node id of the subscriber</td></tr>
<tr><td>time</td><td>window_start</td><td>  the statistics apply to this time window</td></tr>
<tr><td>time</td><td>window_stop</td><td></td></tr>
<tr><td>int32</td><td>delivered_msgs</td><td>  number of messages delivered during the window</td></tr>
<tr><td>int32</td><td>dropped_msgs</td><td>  numbers of messages dropped during the window</td></tr>
<tr><td>int32</td><td>traffic</td><td>  traffic during the window, in bytes</td></tr>
<tr><td>duration</td><td>period_mean</td><td>  mean/stddev/max period between two messages</td></tr>
<tr><td>duration</td><td>period_stddev</td><td></td></tr>
<tr><td>duration</td><td>period_max</td><td></td></tr>
<tr><td>duration</td><td>stamp_age_mean</td><td>  mean/stddev/max age of the message based on the  timestamp in the message header. In case the  message does not have a header, it will be 0.</td></tr>
<tr><td>duration</td><td>stamp_age_stddev</td><td></td></tr>
<tr><td>duration</td><td>stamp_age_max</td><td></td></tr>
</table>
<h1>sensor_msgs</h1>
<h2><A NAME="sensor_msgs_CameraInfo">sensor_msgs/CameraInfo</A></h2>
<table class="altrowstable"">
<p>  This message defines meta information for a camera. It should be in a  camera namespace on topic "camera_info" and accompanied by up to five  image topics named:     image_raw - raw data from the camera driver, possibly Bayer encoded    image            - monochrome, distorted    image_color      - color, distorted    image_rect       - monochrome, rectified    image_rect_color - color, rectified   The image_pipeline contains packages (image_proc, stereo_image_proc)  for producing the four processed image topics from image_raw and  camera_info. The meaning of the camera parameters are described in  detail at http://www.ros.org/wiki/image_pipeline/CameraInfo.   The image_geometry package provides a user-friendly interface to  common operations using this meta information. If you want to, e.g.,  project a 3d point into image coordinates, we strongly recommend  using image_geometry.   If the camera is uncalibrated, the matrices D, K, R, P should be left  zeroed out. In particular, clients may assume that K[0] == 0.0  indicates an uncalibrated camera.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>                                                                                             Image acquisition info                                                                                                    Time of image acquisition, camera coordinate frame ID</td></tr>
<tr><td>uint32</td><td>height</td><td>  Header frame_id should be optical frame of camera  origin of frame should be optical center of camera  +x should point to the right in the image  +y should point down in the image  +z should point into the plane of the image                                                                                              Calibration Parameters                                                                                                   These are fixed during camera calibration. Their values will be the    same in all messages until the camera is recalibrated. Note that       self-calibrating systems may "recalibrate" frequently.                                                                                        The internal parameters can be used to warp a raw (distorted) image    to:                                                                      1. An undistorted image (requires D and K)                             2. A rectified image (requires D, K, R)                              The projection matrix P projects 3D points into the rectified image.                                                                          The image dimensions with which the camera was calibrated. Normally  this will be the full camera resolution in pixels.</td></tr>
<tr><td>uint32</td><td>width</td><td></td></tr>
<tr><td>string</td><td>distortion_model</td><td>  The distortion model used. Supported models are listed in  sensor_msgs/distortion_models.h. For most cameras, "plumb_bob" - a  simple model of radial and tangential distortion - is sufficent.</td></tr>
<tr><td>float64[]</td><td>D</td><td>  The distortion parameters, size depending on the distortion model.  For "plumb_bob", the 5 parameters are: (k1, k2, t1, t2, k3).</td></tr>
<tr><td>float64[9]</td><td>K</td><td>  Intrinsic camera matrix for the raw (distorted) images.      [fx  0 cx]  K = [ 0 fy cy]      [ 0  0  1]  Projects 3D points in the camera coordinate frame to 2D pixel  coordinates using the focal lengths (fx, fy) and principal point  (cx, cy).</td></tr>
<tr><td>float64[9]</td><td>R</td><td>  Rectification matrix (stereo cameras only)  A rotation matrix aligning the camera coordinate system to the ideal  stereo image plane so that epipolar lines in both stereo images are  parallel.</td></tr>
<tr><td>float64[12]</td><td>P</td><td>  Projection/camera matrix      [fx'  0  cx' Tx]  P = [ 0  fy' cy' Ty]      [ 0   0   1   0]  By convention, this matrix specifies the intrinsic (camera) matrix   of the processed (rectified) image. That is, the left 3x3 portion   is the normal camera intrinsic matrix for the rectified image.  It projects 3D points in the camera coordinate frame to 2D pixel   coordinates using the focal lengths (fx', fy') and principal point   (cx', cy') - these may differ from the values in K.  For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will   also have R = the identity and P[1:3,1:3] = K.  For a stereo pair, the fourth column [Tx Ty 0]' is related to the   position of the optical center of the second camera in the first   camera's frame. We assume Tz = 0 so both cameras are in the same   stereo image plane. The first camera always has Tx = Ty = 0. For   the right (second) camera of a horizontal stereo pair, Ty = 0 and   Tx = -fx' * B, where B is the baseline between the cameras.  Given a 3D point [X Y Z]', the projection (x, y) of the point onto   the rectified image is given by:   [u v w]' = P * [X Y Z 1]'          x = u / w          y = v / w   This holds for both images of a stereo pair.</td></tr>
<tr><td>uint32</td><td>binning_x</td><td>                                                                                              Operational Parameters                                                                                                   These define the image region actually captured by the camera          driver. Although they affect the geometry of the output image, they    may be changed freely without recalibrating the camera.                                                                                       Binning refers here to any camera setting which combines rectangular   neighborhoods of pixels into larger "super-pixels." It reduces the   resolution of the output image to   (width / binning_x) x (height / binning_y).  The default values binning_x = binning_y = 0 is considered the same   as binning_x = binning_y = 1 (no subsampling).</td></tr>
<tr><td>uint32</td><td>binning_y</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_RegionOfInterest">RegionOfInterest</A></td><td>roi</td><td>  Region of interest (subwindow of full camera resolution), given in   full resolution (unbinned) image coordinates. A particular ROI   always denotes the same window of pixels on the camera sensor,   regardless of binning settings.  The default setting of roi (all values 0) is considered the same as   full resolution (roi.width = width, roi.height = height).</td></tr>
</table>
<h2><A NAME="sensor_msgs_ChannelFloat32">sensor_msgs/ChannelFloat32</A></h2>
<table class="altrowstable"">
<p>  This message is used by the PointCloud message to hold optional data  associated with each point in the cloud. The length of the values  array should be the same as the length of the points array in the  PointCloud, and each value should be associated with the corresponding  point.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td>  Channel names in existing practice include:    "u", "v" - row and column (respectively) in the left stereo image.               This is opposite to usual conventions but remains for               historical reasons. The newer PointCloud2 message has no               such problem.    "rgb" - For point clouds produced by color stereo cameras. uint8            (R,G,B) values packed into the least significant 24 bits,            in order.    "intensity" - laser or pixel intensity.    "distance"  The channel name should give semantics of the channel (e.g.  "intensity" instead of "value").</td></tr>
<tr><td>float32[]</td><td>values</td><td>  The values array should be 1-1 with the elements of the associated  PointCloud.</td></tr>
</table>
<h2><A NAME="sensor_msgs_CompressedImage">sensor_msgs/CompressedImage</A></h2>
<table class="altrowstable"">
<p>  This message contains a compressed image</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string</td><td>format</td><td>  Header frame_id should be optical frame of camera  origin of frame should be optical center of cameara  +x should point to the right in the image  +y should point down in the image  +z should point into to plane of the image</td></tr>
<tr><td>uint8[]</td><td>data</td><td>    Acceptable values:      jpeg, png</td></tr>
</table>
<h2><A NAME="sensor_msgs_FluidPressure">sensor_msgs/FluidPressure</A></h2>
<table class="altrowstable"">
<p>   Single pressure reading.  This message is appropriate for measuring the   pressure inside of a fluid (air, water, etc).  This also includes   atmospheric or barometric pressure.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This message is not appropriate for force/pressure contact sensors.</td></tr>
<tr><td>float64</td><td>fluid_pressure</td><td>  frame_id is the location of the pressure sensor</td></tr>
<tr><td>float64</td><td>variance</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_Illuminance">sensor_msgs/Illuminance</A></h2>
<table class="altrowstable"">
<p>   Single photometric illuminance measurement.  Light should be assumed to be   measured along the sensor's x-axis (the area of detection is the y-z plane).   The illuminance should have a 0 or positive value and be received with   the sensor's +X axis pointing toward the light source.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Photometric illuminance is the measure of the human eye's sensitivity of the  intensity of light encountering or passing through a surface.  All other Photometric and Radiometric measurements should  not use this message.  This message cannot represent:  Luminous intensity (candela/light source output)  Luminance (nits/light output per area)  Irradiance (watt/area), etc.</td></tr>
<tr><td>float64</td><td>illuminance</td><td>  frame_id is the location and direction of the reading</td></tr>
<tr><td>float64</td><td>variance</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_Image">sensor_msgs/Image</A></h2>
<table class="altrowstable"">
<p>  This message contains an uncompressed image  (0, 0) is at top-left corner of image </p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>uint32</td><td>height</td><td>  Header frame_id should be optical frame of camera  origin of frame should be optical center of cameara  +x should point to the right in the image  +y should point down in the image  +z should point into to plane of the image  If the frame_id here and the frame_id of the CameraInfo  message associated with the image conflict  the behavior is undefined</td></tr>
<tr><td>uint32</td><td>width</td><td></td></tr>
<tr><td>string</td><td>encoding</td><td>  The legal values for encoding are in file src/image_encodings.cpp  If you want to standardize a new string format, join  ros-users@lists.sourceforge.net and send an email proposing a new encoding.</td></tr>
<tr><td>uint8</td><td>is_bigendian</td><td>  taken from the list of strings in include/sensor_msgs/image_encodings.h</td></tr>
<tr><td>uint32</td><td>step</td><td></td></tr>
<tr><td>uint8[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_Imu">sensor_msgs/Imu</A></h2>
<table class="altrowstable"">
<p>  This is a message to hold data from an IMU (Inertial Measurement Unit)   Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec   If the covariance of the measurement is known, it should be filled in (if all you know is the   variance of each measurement, e.g. from the datasheet, just put those along the diagonal)  A covariance matrix of all zeros will be interpreted as "covariance unknown", and to use the  data a covariance will have to be assumed or gotten from some other source   If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation   estimate), please set element 0 of the associated covariance matrix to -1  If you are interpreting this message, please check for a value of -1 in the first element of each   covariance matrix, and disregard the associated estimate.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Quaternion">geometry_msgs/Quaternion</A></td><td>orientation</td><td></td></tr>
<tr><td>float64[9]</td><td>orientation_covariance</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>angular_velocity</td><td></td></tr>
<tr><td>float64[9]</td><td>angular_velocity_covariance</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>linear_acceleration</td><td></td></tr>
<tr><td>float64[9]</td><td>linear_acceleration_covariance</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_JointState">sensor_msgs/JointState</A></h2>
<table class="altrowstable"">
<p>  This is a message that holds data to describe the state of a set of torque controlled joints.    The state of each joint (revolute or prismatic) is defined by:   * the position of the joint (rad or m),   * the velocity of the joint (rad/s or m/s) and    * the effort that is applied in the joint (Nm or N).   Each joint is uniquely identified by its name  The header specifies the time at which the joint states were recorded. All the joint states  in one message have to be recorded at the same time.   This message consists of a multiple arrays, one for each part of the joint state.   The goal is to make each of the fields optional. When e.g. your joints have no  effort associated with them, you can leave the effort array empty.    All arrays in this message should have the same size, or be empty.  This is the only way to uniquely associate the joint name with the correct  states.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string[]</td><td>name</td><td></td></tr>
<tr><td>float64[]</td><td>position</td><td></td></tr>
<tr><td>float64[]</td><td>velocity</td><td></td></tr>
<tr><td>float64[]</td><td>effort</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_Joy">sensor_msgs/Joy</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Reports the state of a joysticks axes and buttons.</td></tr>
<tr><td>float32[]</td><td>axes</td><td></td></tr>
<tr><td>int32[]</td><td>buttons</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_JoyFeedback">sensor_msgs/JoyFeedback</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>TYPE_LED</td><td>  Declare of the type of feedback</td></tr>
<tr><td>uint8</td><td>TYPE_RUMBLE</td><td></td></tr>
<tr><td>uint8</td><td>TYPE_BUZZER</td><td></td></tr>
<tr><td>uint8</td><td>type</td><td></td></tr>
<tr><td>uint8</td><td>id</td><td>  This will hold an id number for each type of each feedback.  Example, the first led would be id=0, the second would be id=1</td></tr>
<tr><td>float32</td><td>intensity</td><td>  Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is  actually binary, driver should treat 0<=x<0.5 as off, 0.5<=x<=1 as on.</td></tr>
</table>
<h2><A NAME="sensor_msgs_JoyFeedbackArray">sensor_msgs/JoyFeedbackArray</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#sensor_msgs_JoyFeedback">JoyFeedback[]</A></td><td>array</td><td>  This message publishes values for multiple feedback at once. </td></tr>
</table>
<h2><A NAME="sensor_msgs_LaserEcho">sensor_msgs/LaserEcho</A></h2>
<table class="altrowstable"">
<p>  This message is a submessage of MultiEchoLaserScan and is not intended  to be used separately.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float32[]</td><td>echoes</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_LaserScan">sensor_msgs/LaserScan</A></h2>
<table class="altrowstable"">
<p>  Single scan from a planar laser range-finder   If you have another ranging device with different behavior (e.g. a sonar  array), please find or create a different message, since applications  will make fairly laser-specific assumptions about this data</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float32</td><td>angle_min</td><td>  the first ray in the scan.   in frame frame_id, angles are measured around  the positive Z axis (counterclockwise, if Z is up)  with zero angle being forward along the x axis</td></tr>
<tr><td>float32</td><td>angle_max</td><td></td></tr>
<tr><td>float32</td><td>angle_increment</td><td></td></tr>
<tr><td>float32</td><td>time_increment</td><td></td></tr>
<tr><td>float32</td><td>scan_time</td><td>  is moving, this will be used in interpolating position  of 3d points</td></tr>
<tr><td>float32</td><td>range_min</td><td></td></tr>
<tr><td>float32</td><td>range_max</td><td></td></tr>
<tr><td>float32[]</td><td>ranges</td><td></td></tr>
<tr><td>float32[]</td><td>intensities</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_MagneticField">sensor_msgs/MagneticField</A></h2>
<table class="altrowstable"">
<p>   Measurement of the Magnetic Field vector at a specific location.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  If the covariance of the measurement is known, it should be filled in  (if all you know is the variance of each measurement, e.g. from the datasheet, just put those along the diagonal)  A covariance matrix of all zeros will be interpreted as "covariance unknown",  and to use the data a covariance will have to be assumed or gotten from some  other source</td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>magnetic_field</td><td>  field was measured  frame_id is the location and orientation  of the field measurement</td></tr>
<tr><td>float64[9]</td><td>magnetic_field_covariance</td><td>  field vector in Tesla  If your sensor does not output 3 axes,  put NaNs in the components not reported.</td></tr>
</table>
<h2><A NAME="sensor_msgs_MultiDOFJointState">sensor_msgs/MultiDOFJointState</A></h2>
<table class="altrowstable"">
<p>  Representation of state for joints with multiple degrees of freedom,   following the structure of JointState.   It is assumed that a joint in a system corresponds to a transform that gets applied   along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)  and those 3DOF can be expressed as a transformation matrix, and that transformation  matrix can be converted back to (x, y, yaw)   Each joint is uniquely identified by its name  The header specifies the time at which the joint states were recorded. All the joint states  in one message have to be recorded at the same time.   This message consists of a multiple arrays, one for each part of the joint state.   The goal is to make each of the fields optional. When e.g. your joints have no  wrench associated with them, you can leave the wrench array empty.    All arrays in this message should have the same size, or be empty.  This is the only way to uniquely associate the joint name with the correct  states.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string[]</td><td>joint_names</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Transform">geometry_msgs/Transform[]</A></td><td>transforms</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist[]</A></td><td>twist</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Wrench">geometry_msgs/Wrench[]</A></td><td>wrench</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_MultiEchoLaserScan">sensor_msgs/MultiEchoLaserScan</A></h2>
<table class="altrowstable"">
<p>  Single scan from a multi-echo planar laser range-finder   If you have another ranging device with different behavior (e.g. a sonar  array), please find or create a different message, since applications  will make fairly laser-specific assumptions about this data</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float32</td><td>angle_min</td><td>  the first ray in the scan.   in frame frame_id, angles are measured around  the positive Z axis (counterclockwise, if Z is up)  with zero angle being forward along the x axis</td></tr>
<tr><td>float32</td><td>angle_max</td><td></td></tr>
<tr><td>float32</td><td>angle_increment</td><td></td></tr>
<tr><td>float32</td><td>time_increment</td><td></td></tr>
<tr><td>float32</td><td>scan_time</td><td>  is moving, this will be used in interpolating position  of 3d points</td></tr>
<tr><td>float32</td><td>range_min</td><td></td></tr>
<tr><td>float32</td><td>range_max</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_LaserEcho">LaserEcho[]</A></td><td>ranges</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_LaserEcho">LaserEcho[]</A></td><td>intensities</td><td>  +Inf measurements are out of range  -Inf measurements are too close to determine exact distance.</td></tr>
</table>
<h2><A NAME="sensor_msgs_NavSatFix">sensor_msgs/NavSatFix</A></h2>
<table class="altrowstable"">
<p>  Navigation Satellite fix for any Global Navigation Satellite System   Specified using the WGS 84 reference ellipsoid</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  header.stamp specifies the ROS time for this measurement (the         corresponding satellite time may be reported using the         sensor_msgs/TimeReference message).   header.frame_id is the frame of reference reported by the satellite         receiver, usually the location of the antenna.  This is a         Euclidean frame relative to the vehicle, not a reference         ellipsoid.</td></tr>
<tr><td><A HREF="#sensor_msgs_NavSatStatus">NavSatStatus</A></td><td>status</td><td>  satellite fix status information</td></tr>
<tr><td>float64</td><td>latitude</td><td>  Latitude [degrees]. Positive is north of equator; negative is south.</td></tr>
<tr><td>float64</td><td>longitude</td><td>  Longitude [degrees]. Positive is east of prime meridian; negative is west.</td></tr>
<tr><td>float64</td><td>altitude</td><td>  Altitude [m]. Positive is above the WGS 84 ellipsoid  (quiet NaN if no altitude is available).</td></tr>
<tr><td>float64[9]</td><td>position_covariance</td><td>  Position covariance [m^2] defined relative to a tangential plane  through the reported position. The components are East, North, and  Up (ENU), in row-major order.   Beware: this coordinate system exhibits singularities at the poles.</td></tr>
<tr><td>uint8</td><td>COVARIANCE_TYPE_UNKNOWN</td><td>  If the covariance of the fix is known, fill it in completely. If the  GPS receiver provides the variance of each measurement, put them  along the diagonal. If only Dilution of Precision is available,  estimate an approximate covariance from that.</td></tr>
<tr><td>uint8</td><td>COVARIANCE_TYPE_APPROXIMATED</td><td></td></tr>
<tr><td>uint8</td><td>COVARIANCE_TYPE_DIAGONAL_KNOWN</td><td></td></tr>
<tr><td>uint8</td><td>COVARIANCE_TYPE_KNOWN</td><td></td></tr>
<tr><td>uint8</td><td>position_covariance_type</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_NavSatStatus">sensor_msgs/NavSatStatus</A></h2>
<table class="altrowstable"">
<p>  Navigation Satellite fix status for any Global Navigation Satellite System</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int8</td><td>STATUS_NO_FIX</td><td>  Whether to output an augmented fix is determined by both the fix  type and the last time differential corrections were received.  A  fix is valid when status >= STATUS_FIX.</td></tr>
<tr><td>int8</td><td>STATUS_FIX</td><td></td></tr>
<tr><td>int8</td><td>STATUS_SBAS_FIX</td><td></td></tr>
<tr><td>int8</td><td>STATUS_GBAS_FIX</td><td></td></tr>
<tr><td>int8</td><td>status</td><td></td></tr>
<tr><td>uint16</td><td>SERVICE_GPS</td><td>  Bits defining which Global Navigation Satellite System signals were  used by the receiver.</td></tr>
<tr><td>uint16</td><td>SERVICE_GLONASS</td><td></td></tr>
<tr><td>uint16</td><td>SERVICE_COMPASS</td><td></td></tr>
<tr><td>uint16</td><td>SERVICE_GALILEO</td><td></td></tr>
<tr><td>uint16</td><td>service</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_PointCloud">sensor_msgs/PointCloud</A></h2>
<table class="altrowstable"">
<p>  This message holds a collection of 3d points, plus optional additional  information about each point.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Time of sensor data acquisition, coordinate frame ID.</td></tr>
<tr><td><A HREF="#geometry_msgs_Point32">geometry_msgs/Point32[]</A></td><td>points</td><td>  Array of 3d points. Each Point32 should be interpreted as a 3d point  in the frame given in the header.</td></tr>
<tr><td><A HREF="#sensor_msgs_ChannelFloat32">ChannelFloat32[]</A></td><td>channels</td><td>  Each channel should have the same number of elements as points array,  and the data in each channel should correspond 1:1 with each point.  Channel names in common practice are listed in ChannelFloat32.msg.</td></tr>
</table>
<h2><A NAME="sensor_msgs_PointCloud2">sensor_msgs/PointCloud2</A></h2>
<table class="altrowstable"">
<p>  This message holds a collection of N-dimensional points, which may  contain additional information such as normals, intensity, etc. The  point data is stored as a binary blob, its layout described by the  contents of the "fields" array.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  The point cloud data may be organized 2d (image-like) or 1d  (unordered). Point clouds organized as 2d images may be produced by  camera depth sensors such as stereo or time-of-flight.  Time of sensor data acquisition, and the coordinate frame ID (for 3d  points).</td></tr>
<tr><td>uint32</td><td>height</td><td>  2D structure of the point cloud. If the cloud is unordered, height is  1 and width is the length of the point cloud.</td></tr>
<tr><td>uint32</td><td>width</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_PointField">PointField[]</A></td><td>fields</td><td>  Describes the channels and their layout in the binary data blob.</td></tr>
<tr><td>bool</td><td>is_bigendian</td><td></td></tr>
<tr><td>uint32</td><td>point_step</td><td></td></tr>
<tr><td>uint32</td><td>row_step</td><td></td></tr>
<tr><td>uint8[]</td><td>data</td><td></td></tr>
<tr><td>bool</td><td>is_dense</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_PointField">sensor_msgs/PointField</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>INT8</td><td>  This message holds the description of one point entry in the  PointCloud2 message format.</td></tr>
<tr><td>uint8</td><td>UINT8</td><td></td></tr>
<tr><td>uint8</td><td>INT16</td><td></td></tr>
<tr><td>uint8</td><td>UINT16</td><td></td></tr>
<tr><td>uint8</td><td>INT32</td><td></td></tr>
<tr><td>uint8</td><td>UINT32</td><td></td></tr>
<tr><td>uint8</td><td>FLOAT32</td><td></td></tr>
<tr><td>uint8</td><td>FLOAT64</td><td></td></tr>
<tr><td>string</td><td>name</td><td></td></tr>
<tr><td>uint32</td><td>offset</td><td></td></tr>
<tr><td>uint8</td><td>datatype</td><td></td></tr>
<tr><td>uint32</td><td>count</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_Range">sensor_msgs/Range</A></h2>
<table class="altrowstable"">
<p>  Single range reading from an active ranger that emits energy and reports  one range reading that is valid along an arc at the distance measured.   This message is  not appropriate for laser scanners. See the LaserScan  message if you are working with a laser scanner.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  This message also can represent a fixed-distance (binary) ranger.  This  sensor will have min_range===max_range===distance of detection.  These sensors follow REP 117 and will output -Inf if the object is detected  and +Inf if the object is outside of the detection range.</td></tr>
<tr><td>uint8</td><td>ULTRASOUND=0</td><td>  returned the distance reading  Radiation type enums  If you want a value added to this list, send an email to the ros-users list</td></tr>
<tr><td>uint8</td><td>INFRARED=1</td><td></td></tr>
<tr><td>uint8</td><td>radiation_type</td><td></td></tr>
<tr><td>float32</td><td>field_of_view</td><td>  (sound, IR, etc) [enum]</td></tr>
<tr><td>float32</td><td>min_range</td><td>  valid for [rad]  the object causing the range reading may have  been anywhere within -field_of_view/2 and  field_of_view/2 at the measured range.  0 angle corresponds to the x-axis of the sensor.</td></tr>
<tr><td>float32</td><td>max_range</td><td></td></tr>
<tr><td>float32</td><td>range</td><td>  Fixed distance rangers require min_range==max_range</td></tr>
</table>
<h2><A NAME="sensor_msgs_RegionOfInterest">sensor_msgs/RegionOfInterest</A></h2>
<table class="altrowstable"">
<p>  This message is used to specify a region of interest within an image.   When used to specify the ROI setting of the camera when the image was  taken, the height and width fields should either match the height and  width fields for the associated image; or height = width = 0  indicates that the full resolution image was captured.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32</td><td>x_offset</td><td></td></tr>
<tr><td>uint32</td><td>y_offset</td><td>  (0 if the ROI includes the left edge of the image)</td></tr>
<tr><td>uint32</td><td>height</td><td>  (0 if the ROI includes the top edge of the image)</td></tr>
<tr><td>uint32</td><td>width</td><td></td></tr>
<tr><td>bool</td><td>do_rectify</td><td>  True if a distinct rectified ROI should be calculated from the "raw"  ROI in this message. Typically this should be False if the full image  is captured (ROI not used), and True if a subwindow is captured (ROI  used).</td></tr>
</table>
<h2><A NAME="sensor_msgs_RelativeHumidity">sensor_msgs/RelativeHumidity</A></h2>
<table class="altrowstable"">
<p>   Single reading from a relative humidity sensor.  Defines the ratio of partial   pressure of water vapor to the saturated vapor pressure at a temperature.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float64</td><td>relative_humidity</td><td>  frame_id is the location of the humidity sensor</td></tr>
<tr><td>float64</td><td>variance</td><td>  from 0.0 to 1.0.  0.0 is no partial pressure of water vapor  1.0 represents partial pressure of saturation</td></tr>
</table>
<h2><A NAME="sensor_msgs_Temperature">sensor_msgs/Temperature</A></h2>
<table class="altrowstable"">
<p>   Single temperature reading.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>float64</td><td>temperature</td><td>  frame_id is the location of the temperature reading</td></tr>
<tr><td>float64</td><td>variance</td><td></td></tr>
</table>
<h2><A NAME="sensor_msgs_TimeReference">sensor_msgs/TimeReference</A></h2>
<table class="altrowstable"">
<p>  Measurement from an external time source not actively synchronized with the system clock.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>time</td><td>time_ref</td><td>  frame_id is not used</td></tr>
<tr><td>string</td><td>source</td><td></td></tr>
</table>
<h1>shape_msgs</h1>
<h2><A NAME="shape_msgs_Mesh">shape_msgs/Mesh</A></h2>
<table class="altrowstable"">
<p>  Definition of a mesh</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#shape_msgs_MeshTriangle">MeshTriangle[]</A></td><td>triangles</td><td>  list of triangles; the index values refer to positions in vertices[]</td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point[]</A></td><td>vertices</td><td>  the actual vertices that make up the mesh</td></tr>
</table>
<h2><A NAME="shape_msgs_MeshTriangle">shape_msgs/MeshTriangle</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32[3]</td><td>vertex_indices</td><td>  Definition of a triangle's vertices</td></tr>
</table>
<h2><A NAME="shape_msgs_Plane">shape_msgs/Plane</A></h2>
<table class="altrowstable"">
<p>  Representation of a plane, using the plane equation ax + by + cz + d = 0</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64[4]</td><td>coef</td><td>  a := coef[0]  b := coef[1]  c := coef[2]  d := coef[3]</td></tr>
</table>
<h2><A NAME="shape_msgs_SolidPrimitive">shape_msgs/SolidPrimitive</A></h2>
<table class="altrowstable"">
<p>  Define box, sphere, cylinder, cone   All shapes are defined to have their bounding boxes centered around 0,0,0.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>BOX=1</td><td></td></tr>
<tr><td>uint8</td><td>SPHERE=2</td><td></td></tr>
<tr><td>uint8</td><td>CYLINDER=3</td><td></td></tr>
<tr><td>uint8</td><td>CONE=4</td><td></td></tr>
<tr><td>uint8</td><td>type</td><td>  The type of the shape</td></tr>
<tr><td>float64[]</td><td>dimensions</td><td>  The dimensions of the shape</td></tr>
<tr><td>uint8</td><td>BOX_X=0</td><td>  The meaning of the shape dimensions: each constant defines the index in the 'dimensions' array  For the BOX type, the X, Y, and Z dimensions are the length of the corresponding  sides of the box.</td></tr>
<tr><td>uint8</td><td>BOX_Y=1</td><td></td></tr>
<tr><td>uint8</td><td>BOX_Z=2</td><td></td></tr>
<tr><td>uint8</td><td>SPHERE_RADIUS=0</td><td>  For the SPHERE type, only one component is used, and it gives the radius of  the sphere.</td></tr>
<tr><td>uint8</td><td>CYLINDER_HEIGHT=0</td><td>  For the CYLINDER and CONE types, the center line is oriented along  the Z axis.  Therefore the CYLINDER_HEIGHT (CONE_HEIGHT) component  of dimensions gives the height of the cylinder (cone).  The  CYLINDER_RADIUS (CONE_RADIUS) component of dimensions gives the  radius of the base of the cylinder (cone).  Cone and cylinder  primitives are defined to be circular. The tip of the cone is  pointing up, along +Z axis.</td></tr>
<tr><td>uint8</td><td>CYLINDER_RADIUS=1</td><td></td></tr>
<tr><td>uint8</td><td>CONE_HEIGHT=0</td><td></td></tr>
<tr><td>uint8</td><td>CONE_RADIUS=1</td><td></td></tr>
</table>
<h1>smach_msgs</h1>
<h2><A NAME="smach_msgs_SmachContainerInitialStatusCmd">smach_msgs/SmachContainerInitialStatusCmd</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>path</td><td>  The path to the node in the server</td></tr>
<tr><td>string[]</td><td>initial_states</td><td>  The desired initial state(s)</td></tr>
<tr><td>string</td><td>local_data</td><td>  Initial values for the local user data of the state machine  A pickled user data structure  i.e. the UserData's internal dictionary</td></tr>
</table>
<h2><A NAME="smach_msgs_SmachContainerStatus">smach_msgs/SmachContainerStatus</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string</td><td>path</td><td>  The path to this node in the server</td></tr>
<tr><td>string[]</td><td>initial_states</td><td>  The initial state description  Effects an arc from the top state to each one</td></tr>
<tr><td>string[]</td><td>active_states</td><td>  The current state description</td></tr>
<tr><td>string</td><td>local_data</td><td>  A pickled user data structure  i.e. the UserData's internal dictionary</td></tr>
<tr><td>string</td><td>info</td><td>  Debugging info string</td></tr>
</table>
<h2><A NAME="smach_msgs_SmachContainerStructure">smach_msgs/SmachContainerStructure</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string</td><td>path</td><td>  The path to this node in the server</td></tr>
<tr><td>string[]</td><td>children</td><td>  The children of this node</td></tr>
<tr><td>string[]</td><td>internal_outcomes</td><td>  The outcome edges  Each index across these arrays denote one edge</td></tr>
<tr><td>string[]</td><td>outcomes_from</td><td></td></tr>
<tr><td>string[]</td><td>outcomes_to</td><td></td></tr>
<tr><td>string[]</td><td>container_outcomes</td><td>  The potential outcomes from this container</td></tr>
</table>
<h1>std_msgs</h1>
<h2><A NAME="std_msgs_Bool">std_msgs/Bool</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>bool</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Byte">std_msgs/Byte</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>byte</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_ByteMultiArray">std_msgs/ByteMultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>byte[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Char">std_msgs/Char</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>char</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_ColorRGBA">std_msgs/ColorRGBA</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float32</td><td>r</td><td></td></tr>
<tr><td>float32</td><td>g</td><td></td></tr>
<tr><td>float32</td><td>b</td><td></td></tr>
<tr><td>float32</td><td>a</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Duration">std_msgs/Duration</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>duration</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Empty">std_msgs/Empty</A></h2>
<table class="altrowstable"">
<p></p></table>
<h2><A NAME="std_msgs_Float32">std_msgs/Float32</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float32</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Float32MultiArray">std_msgs/Float32MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>float32[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Float64">std_msgs/Float64</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Float64MultiArray">std_msgs/Float64MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>float64[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Header">std_msgs/Header</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32</td><td>seq</td><td>  Standard metadata for higher-level stamped data types.  This is generally used to communicate timestamped data   in a particular coordinate frame.    sequence ID: consecutively increasing ID </td></tr>
<tr><td>time</td><td>stamp</td><td> Two-integer timestamp that is expressed as:  * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')  * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')  time-handling sugar is provided by the client library</td></tr>
<tr><td>string</td><td>frame_id</td><td> Frame this data is associated with  0: no frame  1: global frame</td></tr>
</table>
<h2><A NAME="std_msgs_Int16">std_msgs/Int16</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int16</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int16MultiArray">std_msgs/Int16MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>int16[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int32">std_msgs/Int32</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int32</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int32MultiArray">std_msgs/Int32MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>int32[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int64">std_msgs/Int64</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int64</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int64MultiArray">std_msgs/Int64MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>int64[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int8">std_msgs/Int8</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>int8</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Int8MultiArray">std_msgs/Int8MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>int8[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_MultiArrayDimension">std_msgs/MultiArrayDimension</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>label</td><td></td></tr>
<tr><td>uint32</td><td>size</td><td></td></tr>
<tr><td>uint32</td><td>stride</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_MultiArrayLayout">std_msgs/MultiArrayLayout</A></h2>
<table class="altrowstable"">
<p>  The multiarray declares a generic multi-dimensional array of a  particular data type.  Dimensions are ordered from outer most  to inner most.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayDimension">MultiArrayDimension[]</A></td><td>dim</td><td></td></tr>
<tr><td>uint32</td><td>data_offset</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_String">std_msgs/String</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_Time">std_msgs/Time</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>time</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt16">std_msgs/UInt16</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint16</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt16MultiArray">std_msgs/UInt16MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>uint16[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt32">std_msgs/UInt32</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt32MultiArray">std_msgs/UInt32MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>uint32[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt64">std_msgs/UInt64</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint64</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt64MultiArray">std_msgs/UInt64MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>uint64[]</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt8">std_msgs/UInt8</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>data</td><td></td></tr>
</table>
<h2><A NAME="std_msgs_UInt8MultiArray">std_msgs/UInt8MultiArray</A></h2>
<table class="altrowstable"">
<p>  Please look at the MultiArrayLayout message definition for  documentation on all multiarrays.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#std_msgs_MultiArrayLayout">MultiArrayLayout</A></td><td>layout</td><td></td></tr>
<tr><td>uint8[]</td><td>data</td><td></td></tr>
</table>
<h1>stereo_msgs</h1>
<h2><A NAME="stereo_msgs_DisparityImage">stereo_msgs/DisparityImage</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Separate header for compatibility with current TimeSynchronizer.  Likely to be removed in a later release, use image.header instead.</td></tr>
<tr><td><A HREF="#sensor_msgs_Image">sensor_msgs/Image</A></td><td>image</td><td>  Floating point disparity image. The disparities are pre-adjusted for any  x-offset between the principal points of the two cameras (in the case  that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)</td></tr>
<tr><td>float32</td><td>f</td><td>  Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.</td></tr>
<tr><td>float32</td><td>T</td><td></td></tr>
<tr><td><A HREF="#sensor_msgs_RegionOfInterest">sensor_msgs/RegionOfInterest</A></td><td>valid_window</td><td>  Subwindow of (potentially) valid disparity values.</td></tr>
<tr><td>float32</td><td>min_disparity</td><td>  The range of disparities searched.  In the disparity image, any disparity less than min_disparity is invalid.  The disparity search range defines the horopter, or 3D volume that the  stereo algorithm can "see". Points with Z outside of:      Z_min = fT / max_disparity      Z_max = fT / min_disparity  could not be found.</td></tr>
<tr><td>float32</td><td>max_disparity</td><td></td></tr>
<tr><td>float32</td><td>delta_d</td><td>  Smallest allowed disparity increment. The smallest achievable depth range  resolution is delta_Z = (Z^2/fT)*delta_d.</td></tr>
</table>
<h1>tf2_geometry_msgs</h1>
<h1>tf2_msgs</h1>
<h2><A NAME="tf2_msgs_LookupTransformAction">tf2_msgs/LookupTransformAction</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#tf2_msgs_LookupTransformActionGoal">LookupTransformActionGoal</A></td><td>action_goal</td><td></td></tr>
<tr><td><A HREF="#tf2_msgs_LookupTransformActionResult">LookupTransformActionResult</A></td><td>action_result</td><td></td></tr>
<tr><td><A HREF="#tf2_msgs_LookupTransformActionFeedback">LookupTransformActionFeedback</A></td><td>action_feedback</td><td></td></tr>
</table>
<h2><A NAME="tf2_msgs_LookupTransformActionFeedback">tf2_msgs/LookupTransformActionFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#tf2_msgs_LookupTransformFeedback">LookupTransformFeedback</A></td><td>feedback</td><td></td></tr>
</table>
<h2><A NAME="tf2_msgs_LookupTransformActionGoal">tf2_msgs/LookupTransformActionGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalID">actionlib_msgs/GoalID</A></td><td>goal_id</td><td></td></tr>
<tr><td><A HREF="#tf2_msgs_LookupTransformGoal">LookupTransformGoal</A></td><td>goal</td><td></td></tr>
</table>
<h2><A NAME="tf2_msgs_LookupTransformActionResult">tf2_msgs/LookupTransformActionResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td><A HREF="#actionlib_msgs_GoalStatus">actionlib_msgs/GoalStatus</A></td><td>status</td><td></td></tr>
<tr><td><A HREF="#tf2_msgs_LookupTransformResult">LookupTransformResult</A></td><td>result</td><td></td></tr>
</table>
<h2><A NAME="tf2_msgs_LookupTransformFeedback">tf2_msgs/LookupTransformFeedback</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p></table>
<h2><A NAME="tf2_msgs_LookupTransformGoal">tf2_msgs/LookupTransformGoal</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ====== Simple API</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>target_frame</td><td></td></tr>
<tr><td>string</td><td>source_frame</td><td></td></tr>
<tr><td>time</td><td>source_time</td><td></td></tr>
<tr><td>duration</td><td>timeout</td><td></td></tr>
<tr><td>time</td><td>target_time</td><td> Advanced API</td></tr>
<tr><td>string</td><td>fixed_frame</td><td></td></tr>
<tr><td>bool</td><td>advanced</td><td> Whether or not to use the advanced API</td></tr>
</table>
<h2><A NAME="tf2_msgs_LookupTransformResult">tf2_msgs/LookupTransformResult</A></h2>
<table class="altrowstable"">
<p>  ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_TransformStamped">geometry_msgs/TransformStamped</A></td><td>transform</td><td></td></tr>
<tr><td><A HREF="#tf2_msgs_TF2Error">tf2_msgs/TF2Error</A></td><td>error</td><td></td></tr>
</table>
<h2><A NAME="tf2_msgs_TF2Error">tf2_msgs/TF2Error</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>NO_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>LOOKUP_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>CONNECTIVITY_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>EXTRAPOLATION_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>INVALID_ARGUMENT_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>TIMEOUT_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>TRANSFORM_ERROR</td><td></td></tr>
<tr><td>uint8</td><td>error</td><td></td></tr>
<tr><td>string</td><td>error_string</td><td></td></tr>
</table>
<h2><A NAME="tf2_msgs_TFMessage">tf2_msgs/TFMessage</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_TransformStamped">geometry_msgs/TransformStamped[]</A></td><td>transforms</td><td></td></tr>
</table>
<h1>tf2_sensor_msgs</h1>
<h1>trajectory_msgs</h1>
<h2><A NAME="trajectory_msgs_JointTrajectory">trajectory_msgs/JointTrajectory</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string[]</td><td>joint_names</td><td></td></tr>
<tr><td><A HREF="#trajectory_msgs_JointTrajectoryPoint">JointTrajectoryPoint[]</A></td><td>points</td><td></td></tr>
</table>
<h2><A NAME="trajectory_msgs_JointTrajectoryPoint">trajectory_msgs/JointTrajectoryPoint</A></h2>
<table class="altrowstable"">
<p>  Each trajectory point specifies either positions[, velocities[, accelerations]]  or positions[, effort] for the trajectory to be executed.  All specified values are in the same order as the joint names in JointTrajectory.msg</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>float64[]</td><td>positions</td><td></td></tr>
<tr><td>float64[]</td><td>velocities</td><td></td></tr>
<tr><td>float64[]</td><td>accelerations</td><td></td></tr>
<tr><td>float64[]</td><td>effort</td><td></td></tr>
<tr><td>duration</td><td>time_from_start</td><td></td></tr>
</table>
<h2><A NAME="trajectory_msgs_MultiDOFJointTrajectory">trajectory_msgs/MultiDOFJointTrajectory</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  The header is used to specify the coordinate frame and the reference time for the trajectory durations</td></tr>
<tr><td>string[]</td><td>joint_names</td><td>  A representation of a multi-dof joint trajectory (each point is a transformation)  Each point along the trajectory will include an array of positions/velocities/accelerations  that has the same length as the array of joint names, and has the same order of joints as  the joint names array.</td></tr>
<tr><td><A HREF="#trajectory_msgs_MultiDOFJointTrajectoryPoint">MultiDOFJointTrajectoryPoint[]</A></td><td>points</td><td></td></tr>
</table>
<h2><A NAME="trajectory_msgs_MultiDOFJointTrajectoryPoint">trajectory_msgs/MultiDOFJointTrajectoryPoint</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#geometry_msgs_Transform">geometry_msgs/Transform[]</A></td><td>transforms</td><td>  Each multi-dof joint can specify a transform (up to 6 DOF)</td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist[]</A></td><td>velocities</td><td>  There can be a velocity specified for the origin of the joint</td></tr>
<tr><td><A HREF="#geometry_msgs_Twist">geometry_msgs/Twist[]</A></td><td>accelerations</td><td>  There can be an acceleration specified for the origin of the joint</td></tr>
<tr><td>duration</td><td>time_from_start</td><td></td></tr>
</table>
<h1>visualization_msgs</h1>
<h2><A NAME="visualization_msgs_ImageMarker">visualization_msgs/ImageMarker</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>CIRCLE=0</td><td></td></tr>
<tr><td>uint8</td><td>LINE_STRIP=1</td><td></td></tr>
<tr><td>uint8</td><td>LINE_LIST=2</td><td></td></tr>
<tr><td>uint8</td><td>POLYGON=3</td><td></td></tr>
<tr><td>uint8</td><td>POINTS=4</td><td></td></tr>
<tr><td>uint8</td><td>ADD=0</td><td></td></tr>
<tr><td>uint8</td><td>REMOVE=1</td><td></td></tr>
<tr><td>Header</td><td>header</td><td></td></tr>
<tr><td>string</td><td>ns</td><td></td></tr>
<tr><td>int32</td><td>id</td><td></td></tr>
<tr><td>int32</td><td>type</td><td></td></tr>
<tr><td>int32</td><td>action</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point</A></td><td>position</td><td></td></tr>
<tr><td>float32</td><td>scale</td><td></td></tr>
<tr><td><A HREF="#std_msgs_ColorRGBA">std_msgs/ColorRGBA</A></td><td>outline_color</td><td></td></tr>
<tr><td>uint8</td><td>filled</td><td></td></tr>
<tr><td><A HREF="#std_msgs_ColorRGBA">std_msgs/ColorRGBA</A></td><td>fill_color</td><td></td></tr>
<tr><td>duration</td><td>lifetime</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point[]</A></td><td>points</td><td></td></tr>
<tr><td><A HREF="#std_msgs_ColorRGBA">std_msgs/ColorRGBA[]</A></td><td>outline_colors</td><td></td></tr>
</table>
<h2><A NAME="visualization_msgs_InteractiveMarker">visualization_msgs/InteractiveMarker</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Time/frame info.  If header.time is set to 0, the marker will be retransformed into  its frame on each timestep. You will receive the pose feedback  in the same frame.  Otherwise, you might receive feedback in a different frame.  For rviz, this will be the current 'fixed frame' set by the user.</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td>  Initial pose. Also, defines the pivot point for rotations.</td></tr>
<tr><td>string</td><td>name</td><td>  Identifying string. Must be globally unique in  the topic that this message is sent through.</td></tr>
<tr><td>string</td><td>description</td><td>  Short description (< 40 characters).</td></tr>
<tr><td>float32</td><td>scale</td><td>  Scale to be used for default controls (default=1).</td></tr>
<tr><td><A HREF="#visualization_msgs_MenuEntry">MenuEntry[]</A></td><td>menu_entries</td><td>  All menu and submenu entries associated with this marker.</td></tr>
<tr><td><A HREF="#visualization_msgs_InteractiveMarkerControl">InteractiveMarkerControl[]</A></td><td>controls</td><td>  List of controls displayed for this marker.</td></tr>
</table>
<h2><A NAME="visualization_msgs_InteractiveMarkerControl">visualization_msgs/InteractiveMarkerControl</A></h2>
<table class="altrowstable"">
<p>  Represents a control that is to be displayed together with an interactive marker</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>name</td><td>  Identifying string for this control.  You need to assign a unique value to this to receive feedback from the GUI  on what actions the user performs on this control (e.g. a button click).</td></tr>
<tr><td><A HREF="#geometry_msgs_Quaternion">geometry_msgs/Quaternion</A></td><td>orientation</td><td>  Defines the local coordinate frame (relative to the pose of the parent  interactive marker) in which is being rotated and translated.  Default: Identity</td></tr>
<tr><td>uint8</td><td>INHERIT</td><td>  Orientation mode: controls how orientation changes.  INHERIT: Follow orientation of interactive marker  FIXED: Keep orientation fixed at initial state  VIEW_FACING: Align y-z plane with screen (x: forward, y:left, z:up).</td></tr>
<tr><td>uint8</td><td>FIXED</td><td></td></tr>
<tr><td>uint8</td><td>VIEW_FACING</td><td></td></tr>
<tr><td>uint8</td><td>orientation_mode</td><td></td></tr>
<tr><td>uint8</td><td>NONE</td><td>  Interaction mode for this control   NONE: This control is only meant for visualization; no context menu.  MENU: Like NONE, but right-click menu is active.  BUTTON: Element can be left-clicked.  MOVE_AXIS: Translate along local x-axis.  MOVE_PLANE: Translate in local y-z plane.  ROTATE_AXIS: Rotate around local x-axis.  MOVE_ROTATE: Combines MOVE_PLANE and ROTATE_AXIS.</td></tr>
<tr><td>uint8</td><td>MENU</td><td></td></tr>
<tr><td>uint8</td><td>BUTTON</td><td></td></tr>
<tr><td>uint8</td><td>MOVE_AXIS</td><td></td></tr>
<tr><td>uint8</td><td>MOVE_PLANE</td><td></td></tr>
<tr><td>uint8</td><td>ROTATE_AXIS</td><td></td></tr>
<tr><td>uint8</td><td>MOVE_ROTATE</td><td></td></tr>
<tr><td>uint8</td><td>MOVE_3D</td><td>  "3D" interaction modes work with the mouse+SHIFT+CTRL or with 3D cursors.  MOVE_3D: Translate freely in 3D space.  ROTATE_3D: Rotate freely in 3D space about the origin of parent frame.  MOVE_ROTATE_3D: Full 6-DOF freedom of translation and rotation about the cursor origin.</td></tr>
<tr><td>uint8</td><td>ROTATE_3D</td><td></td></tr>
<tr><td>uint8</td><td>MOVE_ROTATE_3D</td><td></td></tr>
<tr><td>uint8</td><td>interaction_mode</td><td></td></tr>
<tr><td>bool</td><td>always_visible</td><td>  If true, the contained markers will also be visible  when the gui is not in interactive mode.</td></tr>
<tr><td><A HREF="#visualization_msgs_Marker">Marker[]</A></td><td>markers</td><td>  Markers to be displayed as custom visual representation.  Leave this empty to use the default control handles.   Note:  - The markers can be defined in an arbitrary coordinate frame,    but will be transformed into the local frame of the interactive marker.  - If the header of a marker is empty, its pose will be interpreted as    relative to the pose of the parent interactive marker.</td></tr>
<tr><td>bool</td><td>independent_marker_orientation</td><td>  In VIEW_FACING mode, set this to true if you don't want the markers  to be aligned with the camera view point. The markers will show up  as in INHERIT mode.</td></tr>
<tr><td>string</td><td>description</td><td>  Short description (< 40 characters) of what this control does,  e.g. "Move the robot".  Default: A generic description based on the interaction mode</td></tr>
</table>
<h2><A NAME="visualization_msgs_InteractiveMarkerFeedback">visualization_msgs/InteractiveMarkerFeedback</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Time/frame info.</td></tr>
<tr><td>string</td><td>client_id</td><td>  Identifying string. Must be unique in the topic namespace.</td></tr>
<tr><td>string</td><td>marker_name</td><td>  Feedback message sent back from the GUI, e.g.  when the status of an interactive marker was modified by the user.  Specifies which interactive marker and control this message refers to</td></tr>
<tr><td>string</td><td>control_name</td><td></td></tr>
<tr><td>uint8</td><td>KEEP_ALIVE</td><td>  Type of the event  KEEP_ALIVE: sent while dragging to keep up control of the marker  MENU_SELECT: a menu entry has been selected  BUTTON_CLICK: a button control has been clicked  POSE_UPDATE: the pose has been changed using one of the controls</td></tr>
<tr><td>uint8</td><td>POSE_UPDATE</td><td></td></tr>
<tr><td>uint8</td><td>MENU_SELECT</td><td></td></tr>
<tr><td>uint8</td><td>BUTTON_CLICK</td><td></td></tr>
<tr><td>uint8</td><td>MOUSE_DOWN</td><td></td></tr>
<tr><td>uint8</td><td>MOUSE_UP</td><td></td></tr>
<tr><td>uint8</td><td>event_type</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td>  Current pose of the marker  Note: Has to be valid for all feedback types.</td></tr>
<tr><td>uint32</td><td>menu_entry_id</td><td>  Contains the ID of the selected menu entry  Only valid for MENU_SELECT events.</td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point</A></td><td>mouse_point</td><td>  If event_type is BUTTON_CLICK, MOUSE_DOWN, or MOUSE_UP, mouse_point  may contain the 3 dimensional position of the event on the  control.  If it does, mouse_point_valid will be true.  mouse_point  will be relative to the frame listed in the header.</td></tr>
<tr><td>bool</td><td>mouse_point_valid</td><td></td></tr>
</table>
<h2><A NAME="visualization_msgs_InteractiveMarkerInit">visualization_msgs/InteractiveMarkerInit</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>server_id</td><td>  Identifying string. Must be unique in the topic namespace  that this server works on.</td></tr>
<tr><td>uint64</td><td>seq_num</td><td>  Sequence number.  The client will use this to detect if it has missed a subsequent  update.  Every update message will have the same sequence number as  an init message.  Clients will likely want to unsubscribe from the  init topic after a successful initialization to avoid receiving  duplicate data.</td></tr>
<tr><td><A HREF="#visualization_msgs_InteractiveMarker">InteractiveMarker[]</A></td><td>markers</td><td>  All markers.</td></tr>
</table>
<h2><A NAME="visualization_msgs_InteractiveMarkerPose">visualization_msgs/InteractiveMarkerPose</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>Header</td><td>header</td><td>  Time/frame info.</td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td>  Initial pose. Also, defines the pivot point for rotations.</td></tr>
<tr><td>string</td><td>name</td><td>  Identifying string. Must be globally unique in  the topic that this message is sent through.</td></tr>
</table>
<h2><A NAME="visualization_msgs_InteractiveMarkerUpdate">visualization_msgs/InteractiveMarkerUpdate</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>string</td><td>server_id</td><td>  Identifying string. Must be unique in the topic namespace  that this server works on.</td></tr>
<tr><td>uint64</td><td>seq_num</td><td>  Sequence number.  The client will use this to detect if it has missed an update.</td></tr>
<tr><td>uint8</td><td>KEEP_ALIVE</td><td>  Type holds the purpose of this message.  It must be one of UPDATE or KEEP_ALIVE.  UPDATE: Incremental update to previous state.          The sequence number must be 1 higher than for          the previous update.  KEEP_ALIVE: Indicates the that the server is still living.              The sequence number does not increase.              No payload data should be filled out (markers, poses, or erases).</td></tr>
<tr><td>uint8</td><td>UPDATE</td><td></td></tr>
<tr><td>uint8</td><td>type</td><td></td></tr>
<tr><td><A HREF="#visualization_msgs_InteractiveMarker">InteractiveMarker[]</A></td><td>markers</td><td> Note: No guarantees on the order of processing.       Contents must be kept consistent by sender. Markers to be added or updated</td></tr>
<tr><td><A HREF="#visualization_msgs_InteractiveMarkerPose">InteractiveMarkerPose[]</A></td><td>poses</td><td> Poses of markers that should be moved</td></tr>
<tr><td>string[]</td><td>erases</td><td> Names of markers to be erased</td></tr>
</table>
<h2><A NAME="visualization_msgs_Marker">visualization_msgs/Marker</A></h2>
<table class="altrowstable"">
<p>  See http://www.ros.org/wiki/rviz/DisplayTypes/Marker and http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes for more information on using this message with rviz</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint8</td><td>ARROW=0</td><td></td></tr>
<tr><td>uint8</td><td>CUBE=1</td><td></td></tr>
<tr><td>uint8</td><td>SPHERE=2</td><td></td></tr>
<tr><td>uint8</td><td>CYLINDER=3</td><td></td></tr>
<tr><td>uint8</td><td>LINE_STRIP=4</td><td></td></tr>
<tr><td>uint8</td><td>LINE_LIST=5</td><td></td></tr>
<tr><td>uint8</td><td>CUBE_LIST=6</td><td></td></tr>
<tr><td>uint8</td><td>SPHERE_LIST=7</td><td></td></tr>
<tr><td>uint8</td><td>POINTS=8</td><td></td></tr>
<tr><td>uint8</td><td>TEXT_VIEW_FACING=9</td><td></td></tr>
<tr><td>uint8</td><td>MESH_RESOURCE=10</td><td></td></tr>
<tr><td>uint8</td><td>TRIANGLE_LIST=11</td><td></td></tr>
<tr><td>uint8</td><td>ADD=0</td><td></td></tr>
<tr><td>uint8</td><td>MODIFY=0</td><td></td></tr>
<tr><td>uint8</td><td>DELETE=2</td><td></td></tr>
<tr><td>Header</td><td>header</td><td> uint8 DELETEALL=3   TODO: enable for ROS-J, disabled for now but functionality is still there. Allows one to clear all markers in plugin</td></tr>
<tr><td>string</td><td>ns</td><td></td></tr>
<tr><td>int32</td><td>id</td><td></td></tr>
<tr><td>int32</td><td>type</td><td></td></tr>
<tr><td>int32</td><td>action</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Pose">geometry_msgs/Pose</A></td><td>pose</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Vector3">geometry_msgs/Vector3</A></td><td>scale</td><td></td></tr>
<tr><td><A HREF="#std_msgs_ColorRGBA">std_msgs/ColorRGBA</A></td><td>color</td><td></td></tr>
<tr><td>duration</td><td>lifetime</td><td></td></tr>
<tr><td>bool</td><td>frame_locked</td><td></td></tr>
<tr><td><A HREF="#geometry_msgs_Point">geometry_msgs/Point[]</A></td><td>points</td><td> Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)</td></tr>
<tr><td><A HREF="#std_msgs_ColorRGBA">std_msgs/ColorRGBA[]</A></td><td>colors</td><td> Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...) number of colors must either be 0 or equal to the number of points NOTE: alpha is not yet used</td></tr>
<tr><td>string</td><td>text</td><td>  NOTE: only used for text markers</td></tr>
<tr><td>string</td><td>mesh_resource</td><td>  NOTE: only used for MESH_RESOURCE markers</td></tr>
<tr><td>bool</td><td>mesh_use_embedded_materials</td><td></td></tr>
</table>
<h2><A NAME="visualization_msgs_MarkerArray">visualization_msgs/MarkerArray</A></h2>
<table class="altrowstable"">
<p></p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td><A HREF="#visualization_msgs_Marker">Marker[]</A></td><td>markers</td><td></td></tr>
</table>
<h2><A NAME="visualization_msgs_MenuEntry">visualization_msgs/MenuEntry</A></h2>
<table class="altrowstable"">
<p>  MenuEntry message.</p><tr><th>Type</th><th> Name </th><th> Comment </th></tr>
<tr><td>uint32</td><td>id</td><td>  Each InteractiveMarker message has an array of MenuEntry messages.  A collection of MenuEntries together describe a  menu/submenu/subsubmenu/etc tree, though they are stored in a flat  array.  The tree structure is represented by giving each menu entry  an ID number and a "parent_id" field.  Top-level entries are the  ones with parent_id = 0.  Menu entries are ordered within their  level the same way they are ordered in the containing array.  Parent  entries must appear before their children.  Example:  - id = 3    parent_id = 0    title = "fun"  - id = 2    parent_id = 0    title = "robot"  - id = 4    parent_id = 2    title = "pr2"  - id = 5    parent_id = 2    title = "turtle"   Gives a menu tree like this:   - fun   - robot     - pr2     - turtle  ID is a number for each menu entry.  Must be unique within the  control, and should never be 0.</td></tr>
<tr><td>uint32</td><td>parent_id</td><td>  ID of the parent of this menu entry, if it is a submenu.  If this  menu entry is a top-level entry, set parent_id to 0.</td></tr>
<tr><td>string</td><td>title</td><td>  menu / entry title</td></tr>
<tr><td>string</td><td>command</td><td>  Arguments to command indicated by command_type (below)</td></tr>
<tr><td>uint8</td><td>FEEDBACK=0</td><td>  Command_type stores the type of response desired when this menu  entry is clicked.  FEEDBACK: send an InteractiveMarkerFeedback message with menu_entry_id set to this entry's id.  ROSRUN: execute "rosrun" with arguments given in the command field (above).  ROSLAUNCH: execute "roslaunch" with arguments given in the command field (above).</td></tr>
<tr><td>uint8</td><td>ROSRUN=1</td><td></td></tr>
<tr><td>uint8</td><td>ROSLAUNCH=2</td><td></td></tr>
<tr><td>uint8</td><td>command_type</td><td></td></tr>
</table>
</body></html>